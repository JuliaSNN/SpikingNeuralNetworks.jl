var documenterSearchIndex = {"docs":
[{"location":"api_reference/#API-References","page":"API References","title":"API References","text":"","category":"section"},{"location":"api_reference/","page":"API References","title":"API References","text":"Pages = [\"api_reference.md\"]","category":"page"},{"location":"api_reference/#Functions","page":"API References","title":"Functions","text":"","category":"section"},{"location":"api_reference/#SNNModels.CV_isi2-Tuple{Vector{Float32}}","page":"API References","title":"SNNModels.CV_isi2","text":"CV_isi2(intervals::Vector{Float32})\n\nReturn the local coefficient of variation of the interspike intervals\nHolt, G. R., Softky, W. R., Koch, C., & Douglas, R. J. (1996). Comparison of discharge variability in vitro and in vivo in cat visual cortex neurons. Journal of Neurophysiology, 75(5), 1806–1814. https://doi.org/10.1152/jn.1996.75.5.1806\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.C_mem-Tuple{}","page":"API References","title":"SNNModels.C_mem","text":"C_mem(;Cd=Cd,d=d,l=l)\nCapacitance of a cylinder of length l and diameter d\nreturn Capacitance in pF\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.G_axial-Tuple{}","page":"API References","title":"SNNModels.G_axial","text":"G_axial(;Ri=Ri,d=d,l=l)\nAxial conductance of a cylinder of length l and diameter d\nreturn Conductance in nS\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.G_mem-Tuple{}","page":"API References","title":"SNNModels.G_mem","text":"G_mem(;Rd=Rd,d=d,l=l)\nMembrane conductance of a cylinder of length l and diameter d\nreturn Conductance in nS\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.Synapse","page":"API References","title":"SNNModels.Synapse","text":"Synapse struct represents a synaptic connection with different types of receptors.\n\nFields\n\nAMPA::T: AMPA receptor\nNMDA::T: NMDA receptor (with voltage dependency)\nGABAa::T: GABAa receptor\nGABAb::T: GABAb receptor\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.Synapse-Tuple{SNNModels.Glutamatergic, SNNModels.GABAergic}","page":"API References","title":"SNNModels.Synapse","text":"Construct a Synapse from Glutamatergic and GABAergic receptors.\n\nArguments\n\nglu::Glutamatergic: Glutamatergic receptors\ngaba::GABAergic: GABAergic receptors\n\nReturns\n\nSynapse: A Synapse object\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.alpha_function-Tuple{Float32, Float32}","page":"API References","title":"SNNModels.alpha_function","text":"alpha_function(t::T; t0::T, τ::T) where T <: AbstractFloat\n\nAlpha function for convolution of spiketimes. Evaluate the alpha function at time t, with time of peak t0 and time constant τ.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.asynchronous_state","page":"API References","title":"SNNModels.asynchronous_state","text":"inter_spike_interval(spiketimes::Vector{Float32})\n\nCalculate the inter-spike intervals (ISIs) for a given set of spike times.\n\nArguments\n\nspiketimes: A vector of spike times for a single neuron.\n\nReturns\n\nisis: A vector of inter-spike intervals.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.bin_spiketimes-Tuple{Vector{Float32}}","page":"API References","title":"SNNModels.bin_spiketimes","text":"bin_spiketimes(spiketimes, interval, sr)\n\nGiven a list of spike times spiketimes, an interval [start, end], and a sampling rate sr, this function counts the number of spikes that fall within each time bin of width 1/sr within the interval. The function returns a sparse matrix count containing the spike counts for each bin, and an array r containing the time points corresponding to the center of each bin.\n\nArguments\n\nspiketimes: A 1-dimensional array of spike times.\ninterval: A 2-element array specifying the start and end times of the interval.\nsr: The sampling rate, i.e., the number of time bins per second.\n\nReturns\n\ncount: A sparse matrix containing the spike counts for each time bin.\nr: An array of time points corresponding to the center of each time bin.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.clear_monitor!-Tuple{Any}","page":"API References","title":"SNNModels.clear_monitor!","text":"clear_monitor!(obj)\n\nClears all the records of a given object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.clear_records!-Tuple{AbstractArray}","page":"API References","title":"SNNModels.clear_records!","text":"clear_records!(objs::AbstractArray)\n\nClears the records of multiple objects.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.clear_records!-Tuple{Any, Symbol}","page":"API References","title":"SNNModels.clear_records!","text":"clear_records!(obj, sym::Symbol)\n\nClears the records of a given object for a specific symbol.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.clear_records!-Tuple{Any}","page":"API References","title":"SNNModels.clear_records!","text":"clear_records!(obj)\n\nClears all the records of a given object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.compose-Tuple","page":"API References","title":"SNNModels.compose","text":"compose(kwargs...; syn=nothing, pop=nothing)\n\nMerge multiple models into a single model.\n\nArguments\n\nkwargs...: List of kwarg elements, i.e., dictionary or named tuples, containing the models to be merged.\nif kwarg has elements with :pop and :syn entries, the function copies them into the merged model.\nif kwarg has no :pop and :syn entries, the function iterates over all the elements contained in kwarg and merge them into the model.\nsyn: Optional dictionary of synapses to be merged.\npop: Optional dictionary of populations to be merged.\nstim: Optional dictionary of stimuli to be merged.\n\nReturns\n\nA tuple (pop, syn) representing the merged populations and synapses.\n\nDetails\n\nThis function takes in multiple models represented as keyword arguments and merges them into a single model. The models can be specified using the pop and syn fields in the keyword arguments. If the pop and syn fields are not present, the function expects the keyword arguments to have elements with :pop or :syn fields.\n\nThe merged populations and synapses are stored in dictionaries populations and synapses, respectively. The function performs type assertions to ensure that the elements being merged are of the correct types (AbstractPopulation for populations and AbstractConnection for synapses).\n\nIf syn and/or pop and/or stim arguments are provided, they are merged into the respective dictionaries.\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.compute_connections-Tuple{Symbol, Symbol, Any}","page":"API References","title":"SNNModels.compute_connections","text":"compute_long_short_connections(pre::Symbol, post::Symbol, points; dc, pl, ϵ, grid_size, conn)\n\nCompute the connections between two populations of neurons based on their spatial distance. This function will assign connections with probability p_short for short-range connections and p_long for long-range connections. The weights of the connections are determined by the μ parameter in the conn named tuple.  The function uses a periodic boundary condition to calculate distances in a 2D grid. The total number of connections per the post-synaptic neuron is: ϵ * Npre * pshort + (1 - ϵ) * Npre * plong.\n\nArguments\n\npre::Symbol: The symbol representing the pre-synaptic population.\npost::Symbol: The symbol representing the post-synaptic population.\npoints::NamedTuple: A named tuple containing the spatial points for each population.\ndc::Float64: The critical distance for short-range connections.\npl::Float64: The probability of long-range connections.\nϵ::Float64: The scaling factor for connection probabilities.\ngrid_size::Float64: The size of the grid.\nconn::NamedTuple: A named tuple containing connection parameters, including p and μ.\n\nReturns\n\nP::Matrix{Bool}: A matrix indicating the presence of connections.\nW::Matrix{Float32}: A matrix containing the weights of the connections.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.compute_covariance_density-Tuple{Vector{Float32}, Vector{Float32}}","page":"API References","title":"SNNModels.compute_covariance_density","text":"compute_covariance_density(t_post, t_pre, T; τ=200ms, sr=50Hz)\n\nCompute the covariance density of spike trains t_post and t_pre over a time interval T. The function returns the covariance density vectors for positive and negative time lags.\n\nArguments\n\nspike_times1:: Vector{Float32}: A vector of spike times for the first neuron.\nspike_times2:: Vector{Float32}: A vector of spike times for the second neuron.\nbin_width:: Float32: The width of the time bins in milliseconds.\nmax_lag:: Float32: The maximum time lag in milliseconds.\n\nReturns\n\nlags:: Vector{Float32}: The time lags in milliseconds.\ncovariance_density:: Vector{Float32}: The covariance density for each time lag.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.compute_cross_correlogram","page":"API References","title":"SNNModels.compute_cross_correlogram","text":"autocor(spiketimes::Spiketimes; interval = 0:1:1000)\n\nCalculate the cross-correlation of two spike trains.\n\nArguments\n\nspike_times1: A vector of spike times for the first neuron.\nspike_times2: A vector of spike times for the second neuron.\nbin_width: The width of the time bins in milliseconds.\nmax_lag: The maximum time lag in milliseconds.\n\nReturns\n\nlags: The time lags in milliseconds.\nauto_corr: The auto-correlation for each time lag.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.extract_items-Tuple{Symbol, Any}","page":"API References","title":"SNNModels.extract_items","text":"extract_items(root::Symbol, container; pop::Dict{Symbol,Any}, syn::Dict{Symbol, Any}, stim::Dict{Symbol,Any})\n\nExtracts items from a container and adds them to the corresponding dictionaries based on their type.\n\nArguments\n\nroot::Symbol: The root symbol for the items being extracted.\ncontainer: The container from which to extract items.\npop::Dict{Symbol,Any}: The dictionary to store population items.\nsyn::Dict{Symbol, Any}: The dictionary to store synapse items.\nstim::Dict{Symbol,Any}: The dictionary to store stimulus items.\n\nReturns\n\ntrue: Always returns true.\n\nDetails\n\nIf the type of the item in the container is AbstractPopulation, it is added to the pop dictionary.\nIf the type of the item in the container is AbstractConnection, it is added to the syn dictionary.\nIf the type of the item in the container is AbstractStimulus, it is added to the stim dictionary.\nIf the type of the item in the container is none of the above, the function is recursively called to extract items from the nested container.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.firing_rate-Tuple{Vector{Vector{Float32}}}","page":"API References","title":"SNNModels.firing_rate","text":"firing_rate(\n    spiketimes::Spiketimes,\n    interval::AbstractVector = [],\n    sampling = 20,\n    τ = 25,\n    ttf = -1,\n    tt0 = -1,\n    cache = true,\n    pop::Union{Symbol,Vector{Int}}= :ALL,\n)\n\nCalculate the firing rates for a population or an individual neuron.\n\nArguments\n\nspiketimes: Spiketimes object.\ninterval: Time interval vector (default is an empty vector).\nsampling: Sampling rate (default is 20ms).\nτ: Time constant for convolution (default is 25ms).\nttf: Final time point (default is -1, which means until the end of the simulation time).\ntt0: Initial time point (default is -1, which means from the start of the simulation time based on the sampling rate).\ncache: If true, uses cached data (default is true).\npop: Either :ALL for all populations or a Vector of Integers specifying specific neuron indices. Default is :ALL.\n\nReturns\n\nA tuple containing:\n\nrates: A vector of firing rates for each neuron in the chosen population.\ninterval: The time interval over which the firing rates were calculated.\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.firing_rate_average-Tuple{Any}","page":"API References","title":"SNNModels.firing_rate_average","text":"firing_rate_average(P; dt=0.1ms)\n\nCalculates and returns the average firing rates of neurons in a network.\n\nArguments:\n\nP: A structure containing neural data, with a key :fire in its records field which stores spike information for each neuron.\ndt: An optional parameter specifying the time interval (default is 0.1ms).\n\nReturns:\n\nAn array of floating point values representing the average firing rate for each neuron.\n\nUsage:# Notes:\n\nEach row of P.records[:fire] represents a neuron, and each column represents a time point. The value in a cell indicates whether that neuron has fired at that time point (non-zero value means it has fired). The firing rate of a neuron is calculated as the total number of spikes divided by the total time span.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.gaussian_kernel-Tuple{Real, Int64}","page":"API References","title":"SNNModels.gaussian_kernel","text":"gaussian_kernel(σ::Float64, length::Int)\n\nCreate a Gaussian kernel with standard deviation σ and specified length.\n\nArguments\n\nσ: Standard deviation of the Gaussian kernel.\nlength: Length of the kernel.\n\nReturns\n\nkernel: A vector representing the Gaussian kernel.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.gaussian_kernel_estimate-Tuple{Vector, Real}","page":"API References","title":"SNNModels.gaussian_kernel_estimate","text":"gaussian_kernel_estimate(support_vector::Vector{Float64}, σ::Float64, length::Int)\n\nApply a Gaussian kernel estimate to a support vector with closed boundary conditions.\n\nArguments\n\nsupport_vector: The input support vector.\nσ: Standard deviation of the Gaussian kernel.\nlength: Length of the kernel.\n\nReturns\n\nestimated_vector: The estimated vector after applying the Gaussian kernel.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.get_dt-Tuple{SNNModels.Time}","page":"API References","title":"SNNModels.get_dt","text":"get_dt(T::Time)\n\nGet the time step size.\n\nArguments\n\nT::Time: The Time object.\n\nReturns\n\nFloat32: The time step size.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.get_interval-Tuple{SNNModels.Time}","page":"API References","title":"SNNModels.get_interval","text":"get_interval(T::Time)\n\nGet the time interval from 0 to the current time.\n\nArguments\n\nT::Time: The Time object.\n\nReturns\n\nStepRange{Float32}: The time interval.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.get_step-Tuple{SNNModels.Time}","page":"API References","title":"SNNModels.get_step","text":"get_step(T::Time)\n\nGet the current time step.\n\nArguments\n\nT::Time: The Time object.\n\nReturns\n\nFloat32: The current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.get_time-Tuple{SNNModels.Time}","page":"API References","title":"SNNModels.get_time","text":"get_time(T::Time)\n\nGet the current time.\n\nArguments\n\nT::Time: The Time object.\n\nReturns\n\nFloat32: The current time.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.getrecord-Tuple{Any, Any}","page":"API References","title":"SNNModels.getrecord","text":"getrecord(p, sym)\n\nReturns the recorded values for a given object and symbol. If the symbol is not found in the object's records, it checks the records of the object's plasticity and returns the values for the matching symbol.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.getvariable","page":"API References","title":"SNNModels.getvariable","text":"getvariable(obj, key, id=nothing)\n\nReturns the recorded values for a given object and key. If an id is provided, returns the recorded values for that specific id.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.graph-Tuple{Any}","page":"API References","title":"SNNModels.graph","text":"graph(model)\n\nGenerate a graph representation of the model.\n\nArguments\n\nmodel: The model to generate the graph from.\n\nReturns\n\nA MetaGraphs.MetaDiGraph object representing the graph.\n\nDetails\n\nEach vertex represents either a population ('pop'), a normalization synapse ('norm'), or a stimulus pre-target ('pre').  Its metadata includes:\nname: Actual name of the population, 'norm' for a SynapseNormalization, or the pre-target's name for a stimulus.\nid: Identifier of the population, SynapseNormalization, or stimulus.\nkey: Key from the original 'pop', 'syn', or 'stim' dictionary in the model.\nEach edge represents a synaptic connection or a stimulus.  Its metadata includes:\ntype: Type of the edge, ':firetog' for SpikingSynapse, ':norm' for SynapseNormalization, or ':stim' for a stimulus.\nname: Name of the edge, formatted as \"fromvertexname to tovertexname\".\nkey: Key from the original 'syn' or 'stim' dictionary in the model.\nid: Identifier of the synapse or stimulus.    \nThe function iterates over the populations, synapses, and stimuli in the model.\n\nAbstractPopulation items are added as vertices.\n\nFor each connection it checks the type of the synapse and adds an edge between the pre-synaptic population and the post-synaptic population.      - SpikingSynapse: the edge represents a connection from the firing population to the receiving population.        - SynapseNormalization: the edge represents a normalization of synapses between populations.     - PoissonStimulus: the edge represents a stimulus from the pre-synaptic population to the post-synaptic population.\n\nFor each stimulus, it adds a vertex to the graph representing an implicit pre-synaptic population [:fire] an edge between it and the post-synaptic population [:post].\n\nReturns a MetaGraphs.MetaDiGraph where:\n\nErrors\n\nThrows ArgumentError when the synapse type is neither SpikingSynapse nor SynapseNormalization.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.interpolated_record-Tuple{Any, Any}","page":"API References","title":"SNNModels.interpolated_record","text":"interpolated_record(p, sym)\n\nReturns the recording with interpolated time values and the extrema of the recorded time points.\n\nN.B. \n----\nThe element can be accessed at whichever time point by using the index of the array. The time point must be within the range of the recorded time points, in r_v.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.interval_standard_spikes-Tuple{Any, Any}","page":"API References","title":"SNNModels.interval_standard_spikes","text":"interval_standard_spikes(spiketimes, interval)\n\nStandardize the spiketimes to the interval [0, interval_duration]. Return a copy of the 'Spiketimes' vector. \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.is_attractor_state-Union{Tuple{T}, Tuple{T, AbstractVector}} where T<:SNNModels.AbstractPopulation","page":"API References","title":"SNNModels.is_attractor_state","text":"is_attractor_state(spiketimes::Spiketimes, interval::AbstractVector, N::Int)\n\nCheck if the network is in an attractor state by verifying that the average firing rate over the last N seconds of the simulation is a unimodal distribution.\n\nArguments\n\nspiketimes: A vector of vectors containing the spike times of each neuron.\ninterval: The time interval over which to compute the firing rate.\nN: The number of seconds over which to check the unimodality of the firing rate distribution.\n\nReturns\n\nis_attractor: A boolean indicating whether the network is in an attractor state.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.linear_network-Tuple{Any}","page":"API References","title":"SNNModels.linear_network","text":"linear_network(N, σ_w=0.38, w_max=2.0)\n\nCreate a linear network with Gaussian-shaped connections.\n\nArguments\n\nN::Int: The number of neurons.\nσ_w::Float64: The standard deviation of the Gaussian distribution.\nw_max::Float64: The maximum weight.\n\nReturns\n\nW::Matrix{Float32}: A matrix containing the weights of the connections.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.merge_spiketimes-Tuple{Vector{Vector{Vector{Float32}}}}","page":"API References","title":"SNNModels.merge_spiketimes","text":"merge_spiketimes(spikes::Vector{Spiketimes}; )\n\nMerge spiketimes from different simulations. \nThis function is not thread safe, it is not recommended to use it in parallel.\nParameters\n----------\nspikes: Vector{Spiketimes}\n    Vector of spiketimes from different simulations\nReturn\n------\nneurons: Spiketimes\n    Single vector of spiketimes\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.monitor!-Union{Tuple{Item}, Tuple{Item, Vector}} where Item<:Union{SNNModels.AbstractConnection, SNNModels.AbstractPopulation, SNNModels.AbstractStimulus}","page":"API References","title":"SNNModels.monitor!","text":"monitor!(obj::Item, keys::Vector; sr = 1000Hz, variables::Symbol = :none) where {Item<:Union{AbstractPopulation,AbstractStimulus,AbstractConnection}}\n\nInitialize monitoring for specified variables in an object.\n\nArguments\n\nobj::Item: The object to monitor (must be a population, stimulus, or connection).\nkeys::Vector: A vector of symbols or tuples specifying variables to monitor.\nIf a symbol is provided, it specifies the variable to monitor.\nIf a tuple is provided, the first element is the variable symbol and the second is a list of indices to monitor.\nsr::Float32: The sampling rate for recording (default: 1000Hz).\nvariables::Symbol: The variable group to monitor (default: :none). If specified, monitors variables within this group.\n\nDetails\n\nThis function sets up monitoring for the specified variables in the object. It initializes necessary recording structures if they don't exist, and configures the sampling rate and indices for each variable to be monitored.\n\nFor firing activity (:fire), it creates a dictionary to store spike times and neuron indices. For other variables, it determines the appropriate data type and creates a vector to store the recorded values.\n\nNotes\n\nIf a variable is not found in the object, a warning is issued.\nIf a variable is already being monitored, a warning is issued.\nThe function handles both direct object fields and nested fields within variable groups.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.neurons_outside_area-NTuple{4, Any}","page":"API References","title":"SNNModels.neurons_outside_area","text":"neurons_outside_area(points, center, distance, grid_size)\n\nFind the indices of neurons outside a specified area around a center point.\n\nArguments\n\npoints::Vector{Vector{Float64}}: The coordinates of the neurons.\ncenter::Vector{Float64}: The coordinates of the center point.\ndistance::Float64: The minimum distance from the center point.\ngrid_size::Float64: The size of the grid.\n\nReturns\n\nindices::Vector{Int}: The indices of neurons outside the specified area.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.neurons_within_circle-NTuple{4, Any}","page":"API References","title":"SNNModels.neurons_within_circle","text":"neurons_within_circle(points, center, distance, grid_size)\n\nFind the indices of neurons within a specified area around a center point.\n\nArguments\n\npoints::Vector{Vector{Float64}}: The coordinates of the neurons.\ncenter::Vector{Float64}: The coordinates of the center point.\ndistance::Float64: The maximum distance from the center point.\ngrid_size::Float64: The size of the grid.\n\nReturns\n\nindices::Vector{Int}: The indices of neurons within the specified area.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.norm_synapse-Tuple{Any, Any}","page":"API References","title":"SNNModels.norm_synapse","text":"Calculate the normalization factor for a synapse given rise and decay time constants.\n\nArguments\n\nτr: Rise time constant\nτd: Decay time constant\n\nReturns\n\nFloat32: The normalization factor\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.norm_synapse-Tuple{SNNModels.Receptor}","page":"API References","title":"SNNModels.norm_synapse","text":"Calculate the normalization factor for a synapse.\n\nArguments\n\nsynapse::Receptor: The receptor for which to calculate the normalization factor\n\nReturns\n\nFloat32: The normalization factor\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.periodic_distance-Tuple{Any, Any, Any}","page":"API References","title":"SNNModels.periodic_distance","text":"periodic_distance(point1, point2, grid_size)\n\nCalculate the periodic distance between two points in a 2D grid.\n\nArguments\n\npoint1::Vector{Float64}: The coordinates of the first point.\npoint2::Vector{Float64}: The coordinates of the second point.\ngrid_size::Float64: The size of the grid.\n\nReturns\n\ndistance::Float64: The periodic distance between the two points.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.place_populations-Tuple{Any, Any}","page":"API References","title":"SNNModels.place_populations","text":"place_populations(config)\n\nCreate a 2D spatial structure and dispose N points for each population.\n\nArguments\n\nconfig::NamedTuple: A NamedTuple containing configuration parameters, including projections and Npop.\n\nReturns\n\nPops::NamedTuple: A named tuple containing the spatial points for each population.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.plasticity!-Tuple{SNNModels.AbstractSparseSynapse, SNNModels.iSTDPPotential, SNNModels.iSTDPVariables, Float32, SNNModels.Time}","page":"API References","title":"SNNModels.plasticity!","text":"plasticity!(c::AbstractSparseSynapse, param::iSTDPRate, dt::Float32)\n\nPerforms the synaptic plasticity calculation based on the inihibitory spike-timing dependent plasticity (iSTDP) model from Vogels (2011) adapted to control the membrane potential.  The function updates synaptic weights W of each synapse in the network according to the firing status of pre and post-synaptic neurons. This is an in-place operation that modifies the input AbstractSparseSynapse object c.\n\nArguments\n\nc::AbstractSparseSynapse: The current spiking synapse object which contains data structures to represent the synapse network.\nparam::iSTDPParameterVoltage: Parameters needed for the iSTDP model, including learning rate η, target membrane potenital v0, STDP time constant τy, maximal and minimal synaptic weight (Wmax and Wmin).\ndt::Float32: The time step for the numerical integration.\n\nAlgorithm\n\nFor each pre-synaptic neuron, if it fires, it reduces the synaptic weight by an amount proportional to the difference between the target membrane potential and the actual one. \nFor each pre-synaptic neuron, if it fires, increases the inhibitory term, otherwise the inhibitory term decays exponentially over time with a time constant τy.\nFor each post-synaptic neuron, if it fires, it increases the synaptic weight by an amount proportional to the pre-synaptic trace and increases the excitatory term, otherwise the excitatory term decays exponentially over time with a time constant τy.\nThe synaptic weights are bounded by Wmin and Wmax.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.plasticity!-Tuple{SNNModels.AbstractSparseSynapse, SNNModels.iSTDPRate, SNNModels.iSTDPVariables, Float32, SNNModels.Time}","page":"API References","title":"SNNModels.plasticity!","text":"plasticity!(c::AbstractSparseSynapse, param::iSTDPRate, dt::Float32)\n\nPerforms the synaptic plasticity calculation based on the inihibitory spike-timing dependent plasticity (iSTDP) model from Vogels (2011).  The function updates synaptic weights W of each synapse in the network according to the firing status of pre and post-synaptic neurons. This is an in-place operation that modifies the input AbstractSparseSynapse object c.\n\nArguments\n\nc::AbstractSparseSynapse: The current spiking synapse object which contains data structures to represent the synapse network.\nparam::iSTDPRate: Parameters needed for the iSTDP model, including learning rate η, target rate r, STDP time constant τy, maximal and minimal synaptic weight (Wmax and Wmin).\ndt::Float32: The time step for the numerical integration.\n\nAlgorithm\n\nFor each pre-synaptic neuron, if it fires, it reduces the synaptic weight by an amount proportional to the difference between the target rate and the actual rate and increases the inhibitory term,  otherwise the inhibitory term decays exponentially over time with a time constant τy.\nFor each post-synaptic neuron, if it fires, it increases the synaptic weight by an amount proportional to the pre-synaptic trace and increases the excitatory term, otherwise the excitatory term decays exponentially over time with a time constant τy.\nThe synaptic weights are bounded by Wmin and Wmax.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.plasticity!-Tuple{SNNModels.AggregateScaling, SNNModels.AggregateScalingParameter, Float32, SNNModels.Time}","page":"API References","title":"SNNModels.plasticity!","text":"plasticity!(c::SynapseNormalization, param::AdditiveNorm, dt::Float32)\n\nUpdates the synaptic weights using additive or multiplicative normalization (operator). This function calculates  the rate of change μ as the difference between initial weight W0 and the current weight W1,  normalized by W1. The weights are updated at intervals specified by time constant τ.\n\nArguments\n\nc: An instance of SynapseNormalization.\nparam: An instance of AdditiveNorm.\ndt: Simulation time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.plasticity!-Tuple{SNNModels.SynapseNormalization, SNNModels.NormParam, Float32, SNNModels.Time}","page":"API References","title":"SNNModels.plasticity!","text":"plasticity!(c::SynapseNormalization, param::AdditiveNorm, dt::Float32)\n\nUpdates the synaptic weights using additive or multiplicative normalization (operator). This function calculates  the rate of change μ as the difference between initial weight W0 and the current weight W1,  normalized by W1. The weights are updated at intervals specified by time constant τ.\n\nArguments\n\nc: An instance of SynapseNormalization.\nparam: An instance of AdditiveNorm.\ndt: Simulation time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.population_indices-Tuple{Any}","page":"API References","title":"SNNModels.population_indices","text":"population_indices(P, type = \"ˆ\")\n\nGiven a dictionary P containing population names as keys and population objects as values, this function returns a named tuple indices that maps each population name to a range of indices. The range represents the indices of the neurons belonging to that population.\n\nArguments\n\nP: A dictionary containing population names as keys and population objects as values.\ntype: A string specifying the type of population to consider. Only population names that contain the specified type will be included in the output. Defaults to \"ˆ\".\n\nReturns\n\nA named tuple indices where each population name is mapped to a range of indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.print_model","page":"API References","title":"SNNModels.print_model","text":"print_model(model)\n\nPrints the details of the given model.  The model is expected to have three components: pop (populations), syn (synapses), and stim (stimuli).\n\nThe function displays a graph representation of the model, followed by detailed information about each component.\n\nArguments\n\nmodel: The model containing populations, synapses, and stimuli to be printed.\n\nOutputs\n\nPrints the graph of the model, along with the name, key, type, and parameters of each component in the populations, synapses, and stimuli.\n\nException\n\nRaises an assertion error if any component in the populations is not a subtype of AbstractPopulation, if any component in the synapses is not a subtype of AbstractConnection, or if any component in the stimuli is not a subtype of AbstractStimulus.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.print_summary-Tuple{Any}","page":"API References","title":"SNNModels.print_summary","text":"print_summary(p)\n\nPrints a summary of the given element.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.record!-Tuple{Any, SNNModels.Time}","page":"API References","title":"SNNModels.record!","text":"record!(obj, T::Time)\n\nRecord the state of the object obj at the current time T.\n\nArguments\n\nobj: The object to record the state from.\nT::Time: The current time object.\n\nDetails\n\nThis function records the state of the object by iterating through all keys in the object's records. For each key:\n\nIf the key is :fire, it records the firing activity using record_fire!.\nFor plasticity variables, it checks if the key starts with a variable name and records the corresponding field.\nFor other fields, it records the field if it exists in the object.\nIt updates the start and end times for each recorded variable.\n\nNotes\n\nThe function skips special keys like :indices, :sr, and :timestamp.\nThe recording is performed only if the sampling rate condition is met.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.record-Tuple{Any, Symbol}","page":"API References","title":"SNNModels.record","text":"record(p, sym::Symbol; range = false, interval = nothing, kwargs...)\n\nRecord data from a population p based on the specified symbol sym.\n\nArguments\n\np: The population from which to record data.\nsym::Symbol: The type of data to record. Valid options are :fire for firing rate, :spiketimes or :spikes for spike times.\nrange::Bool=false: If true, return both the recorded data and the range. Default is false.\ninterval: The time interval for recording. Required for firing rate recording (sym = :fire).\nkwargs...: Additional keyword arguments to pass to the recording function.\n\nReturns\n\nIf sym = :fire and range = true, returns a tuple (v, r) where v is the firing rate and r is the range.\nIf sym = :fire and range = false, returns the firing rate v.\nIf sym = :spiketimes or sym = :spikes, returns the spike times.\nFor other symbols, returns a tuple (v, r) if range = true, or v if range = false.\n\nExamples\n\n```julia\n\nRecord firing rate for a population p over a specific interval\n\nv = record(p, :fire; interval = (0.0, 1.0))\n\nRecord firing rate and range for a population p over a specific interval\n\nv, r = record(p, :fire; range = true, interval = (0.0, 1.0))\n\nRecord spike times for a population p\n\nspikes = record(p, :spiketimes)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.record_fire!-Tuple{Vector{Bool}, Dict{Symbol, AbstractVector}, SNNModels.Time, Dict{Symbol, Vector{Int64}}}","page":"API References","title":"SNNModels.record_fire!","text":"record_fire!(obj::PT, T::Time, indices::Dict{Symbol,Vector{Int}}) where {PT <: Union{AbstractPopulation, AbstractStimulus}}\n\nRecord the firing activity of the obj object into the obj.records[:fire] array.\n\nArguments\n\nobj::PT: The object to record the firing activity from.\nT::Time: The time at which the recording is happening.\nindices::Dict{Symbol,Vector{Int}}: A dictionary containing indices for each variable to record.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.record_sym!-Tuple{Any, Any, Symbol, SNNModels.Time, Dict{Symbol, Vector{Int64}}, Float32}","page":"API References","title":"SNNModels.record_sym!","text":"record_sym!(obj, key::Symbol, T::Time, indices::Dict{Symbol,Vector{Int}})\n\nRecord the variable key of the obj object into the obj.records[key] array.\n\nArguments\n\nobj: The object to record the variable from.\nkey::Symbol: The key of the variable to record.\nT::Time: The time at which the recording is happening.\nindices::Dict{Symbol,Vector{Int}}: A dictionary containing indices for each variable to record.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.relative_time!-Tuple{Vector{Vector{Float32}}, Any}","page":"API References","title":"SNNModels.relative_time!","text":"relative_time(spiketimes::Spiketimes, start_time)\n\nReturn the spiketimes relative to the start_time of the interval\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.sample_spikes-Union{Tuple{R}, Tuple{Any, Vector, R}} where R<:AbstractRange","page":"API References","title":"SNNModels.sample_spikes","text":"sample_spikes(N, rate::Vector, interval::R; dt=0.125f0) where {R <: AbstractRange}\n\nGenerate sample spike times for N neurons from a rate vector. The function generates spike times for each neuron based on the rate vector and the time interval. The spike times are generated such that during the interval of the rate, the number of spikes is Poisson distributed with the rate.\n\nArguments\n\nN: The number of neurons.\nrate::Vector: The vector with the rate to be sampled.\ninterval::R: The time interval over which the rate is recorded.\ndt=0.125f0: The time step size.\n\nReturns\n\nAn array of spike times for each neuron.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.sim!-Union{Tuple{Vector{TP}}, Tuple{TS}, Tuple{TC}, Tuple{TP}, Tuple{Vector{TP}, Vector{TC}}, Tuple{Vector{TP}, Vector{TC}, Vector{TS}}} where {TP<:SNNModels.AbstractPopulation, TC<:SNNModels.AbstractConnection, TS<:SNNModels.AbstractStimulus}","page":"API References","title":"SNNModels.sim!","text":"sim!(\n    P::Vector{TN},\n    C::Vector{TS};\n    dt = 0.1f0,\n    duration = 10.0f0,\n    pbar = false,\n) where {TN <: AbstractPopulation, TS<:AbstractConnection }\n\nSimulates the spiking neural network for a specified duration by repeatedly calling sim! function.\n\nArguments\n\nP::Vector{TN}: Vector of neurons in the network.\nC::Vector{TS}: Vector of synapses in the network.\ndt::Float32: Time step for the simulation. Default value is 0.1f0.\nduration::Float32: Duration of the simulation. Default value is 10.0f0.\npbar::Bool: Flag indicating whether to display a progress bar during the simulation. Default value is false.\n\nDetails\n\nThe function creates a range of time steps from 0.0f0 to duration-dt with a step size of dt.\nIf pbar is true, the function creates a progress bar using the ProgressBar function with the time step range. Otherwise, it uses the time step range directly.\nThe function iterates over the time steps and calls the sim! function with P, C, and dt.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spatial_activity-Tuple{Any, Any}","page":"API References","title":"SNNModels.spatial_activity","text":"spatial_activity(points, activity; N, L, grid_size=(x=0.1, y=0.1))\n\nCompute the spatial average of activity data over a grid.\n\nArguments\n\npoints::Tuple{Vector{Float64}, Vector{Float64}}: A tuple containing two vectors xs and ys, which represent the x and y coordinates of the points.\nactivity::Matrix{Float64}: A matrix where rows correspond to points and columns correspond to activity values over time.\nN::Int: The number of time steps to group together for averaging.\nL::Float64: The size of each grid cell in both x and y directions.\ngrid_size::NamedTuple{(:x, :y), Tuple{Float64, Float64}} (optional): The total size of the grid in the x and y directions. Defaults to (x=0.1, y=0.1).\n\nReturns\n\nspatial_avg::Array{Float64, 3}: A 3D array where the first two dimensions correspond to the grid cells in the x and y directions, and the third dimension corresponds to the time groups. Each element contains the average activity for the points within the corresponding grid cell and time group.\nx_range::Vector{Float64}: A vector representing the range of x coordinates for the grid cells.\ny_range::Vector{Float64}: A vector representing the range of y coordinates for the grid cells.\n\nDetails\n\nThe function divides the spatial domain into a grid based on the grid_size and L parameters. For each grid cell, it computes the average activity of the points that fall within the cell over time groups defined by N. If no points are found in a grid cell, the average for that cell is skipped.\n\nExample\n\nxs = [0.05, 0.15, 0.25, 0.35]\nys = [0.05, 0.15, 0.25, 0.35]\npoints = (xs, ys)\nactivity = rand(4, 100)  # Random activity data for 4 points over 100 time steps\nN = 10\nL = 0.1\ngrid_size = (x=0.4, y=0.4)\n\nspatial_avg, x_range, y_range = spatial_activity(points, activity; N, L, grid_size)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spikecount-Union{Tuple{Q}, Tuple{T}, Tuple{T, Q, Vector{Int64}}} where {T<:SNNModels.AbstractPopulation, Q<:(AbstractVector)}","page":"API References","title":"SNNModels.spikecount","text":"spikecount(model, Trange, neurons)\n\nReturn the total number of spikes of the neurons in the selected interval\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spikes_in_interval","page":"API References","title":"SNNModels.spikes_in_interval","text":"spikesininterval(spiketimes::Spiketimes, interval::AbstractRange)\n\nReturn the spiketimes in the selected interval\n\nArguments\n\nspiketimes::Spiketimes: Vector with each neuron spiketime interval: 2 dimensional array with the start and end of the interval\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.spiketimes-Tuple{Any}","page":"API References","title":"SNNModels.spiketimes","text":"spiketimes(Ps; kwargs...)\n\nReturn the spiketimes of each population in single vector of Spiketimes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spiketimes-Tuple{T} where T<:Union{SNNModels.AbstractPopulation, SNNModels.AbstractStimulus}","page":"API References","title":"SNNModels.spiketimes","text":"spiketimes(p, interval = nothing, indices = nothing)\n\nCompute the spike times of a population.\n\nArguments:\n\np: The network parameters.\ninterval: The time interval within which to compute the spike times. If nothing, the interval is set to (0, firing_time[end]).\n\nReturns:\n\nspiketimes: A vector of vectors containing the spike times of each neuron.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spiketimes_from_bool-Tuple{Any}","page":"API References","title":"SNNModels.spiketimes_from_bool","text":"spiketimes_from_bool(P, τ; dt = 0.1ms)\n\nThis function takes in the records of a neural population P and time constant τ to calculate spike times for each neuron.\n\nArguments\n\nP: A data structure containing the recorded data of a neuronal population.\nτ: A time constant parameter.\n\nKeyword Arguments\n\ndt: The time step used for the simulation, defaults to 0.1 milliseconds.\n\nReturns\n\nspiketimes: An object of type Spiketimes which contains the calculated spike times of each neuron.\n\nExamples\n\njulia\nspiketimes = spike_times(population_records, time_constant)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spiketimes_split-Tuple{Any}","page":"API References","title":"SNNModels.spiketimes_split","text":"spiketimes_split(Ps; kwargs...)\n\nReturn the spiketimes of each population in a vector of Spiketimes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.st_order-Tuple{T} where T<:(Vector)","page":"API References","title":"SNNModels.st_order","text":"st_order(spiketimes::Spiketimes)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.stimulate!-Tuple{SNNModels.BalancedStimulus, SNNModels.BalancedStimulusParameter, SNNModels.Time, Float32}","page":"API References","title":"SNNModels.stimulate!","text":"stimulate!(p::BalancedStimulus, param::BalancedParameter, time::Time, dt::Float32)\n\nGenerate a Balanced stimulus for a postsynaptic population.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.subpopulations","page":"API References","title":"SNNModels.subpopulations","text":"subpopulations(stim)\n\nExtracts the names and the neuron ids projected from a given set of stimuli.\n\nArguments\n\nstim: A dictionary containing stimulus information.\n\nReturns\n\nnames: A vector of strings representing the names of the subpopulations.\npops: A vector of arrays representing the populations of the subpopulations.\n\nExample\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.train!-Union{Tuple{Vector{TP}}, Tuple{TS}, Tuple{TC}, Tuple{TP}, Tuple{Vector{TP}, Vector{TC}}, Tuple{Vector{TP}, Vector{TC}, Vector{TS}}} where {TP<:SNNModels.AbstractPopulation, TC<:SNNModels.AbstractConnection, TS<:SNNModels.AbstractStimulus}","page":"API References","title":"SNNModels.train!","text":"train!(\n    P::Vector{TN},\n    C::Vector{TS};\n    dt = 0.1ms,\n    duration = 10ms,\n) where {TN <: AbstractPopulation, TS<:AbstractConnection }\n\nTrains the spiking neural network for a specified duration by repeatedly calling train! function.\n\nArguments\n\nP::Vector{TN}: Vector of neurons in the network.\nC::Vector{TS}: Vector of synapses in the network.\ndt::Float32: Time step for the training. Default value is 0.1ms.\nduration::Float32: Duration of the training. Default value is 10ms.\n\nDetails\n\nThe function converts dt to Float32 if it is not already.\nThe function creates a progress bar using the ProgressBar function with a range of time steps from 0.0f0 to duration-dt with a step size of dt.\nThe function iterates over the time steps and calls the train! function with P, C, and dt.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.update_time!-Tuple{SNNModels.Time, Float32}","page":"API References","title":"SNNModels.update_time!","text":"update_time!(T::Time, dt::Float32)\n\nUpdate the current time and time step.\n\nArguments\n\nT::Time: The Time object.\ndt::Float32: The time step size.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.α_synapse-Tuple{Any, Any}","page":"API References","title":"SNNModels.α_synapse","text":"Calculate the alpha factor for a synapse given rise and decay time constants.\n\nArguments\n\nτr: Rise time constant\nτd: Decay time constant\n\nReturns\n\nFloat32: The alpha factor\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Plots","page":"API References","title":"Plots","text":"","category":"section"},{"location":"api_reference/#SNNPlots.dendrite_gplot-Tuple{Any, Any}","page":"API References","title":"SNNPlots.dendrite_gplot","text":"dendrite_gplot(population, target; sym_id=1, r, dt, param=:dend_syn, nmda=true, kwargs...)\n\nPlot the synaptic current in the dendrite of a population of neurons. \nThe function uses the synaptic conductance and the membrane potential to calculate the synaptic current.\n\nParameters\n----------\npopulation : AbstractPopulation\n    The population of neurons to plot\ntarget : Symbol\n    The target of the plot, either `:d` for single dendrite or `:d1/:d2` \nneuron : Int\n    The neuron to plot\nr : Array{Int}\n    The time range to plot\nnmda : Bool\n    If true, the NMDA conductance is used to calculate the synaptic current\nkwargs... : Any\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.mutual_EI_connections","page":"API References","title":"SNNPlots.mutual_EI_connections","text":"mutual_EI_connections(synapses, pre, post)\n\nThis function calculates the mutual and unidirectional connections between two populations of neurons, where one population inhibits the other. The function takes a synapses object as input, which contains the synaptic weights between the two populations.\n\nArguments\n\nsynapses: A struct containing the synaptic weights between the two populations of neurons.\n\nOutput\n\nmutual: An array containing the weights of the mutual connections.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNPlots.plot_activity-Tuple{Any, Any}","page":"API References","title":"SNNPlots.plot_activity","text":"plot_activity(network, Trange)\n\nPlot the activity of a spiking neural network with one dendritic excitatory population and two inhibitory populations. The function plots the firing rate of the populations, the membrane potential of the neurons, the synaptic conductance in the dendrite, the synaptic current in the dendrite, and the raster plot of the excitatory population.\n\nArguments:\n\nnetwork: The spiking neural network object.\nTrange: The time range for plotting.\n\nReturns:\n\nNothing.\n\nExample:\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.plot_average_word_activity-NTuple{4, Any}","page":"API References","title":"SNNPlots.plot_average_word_activity","text":"plot_average_word_activity(sym, word, model, seq; target=:d, before=100ms, after=300ms, zscore=true)\n\nPlot the value of the `sym` variable for the neurons associated to the `word` stimulus. \n`neurons = getneurons(model.stim, seq.symbols.words[w], target)`\n\nArguments:\n- `sym`: The variable to plot.\n- `word`: The word stimulus.\n- `model`: The spiking neural network model.\n- `seq`: The sequence of stimuli.\n- `target`: The target compartment (default=:d).\n- `before`: The time before the stimulus (default=100ms).\n- `after`: The time after the stimulus (default=300ms).\n- `zscore`: Whether to z-score the activity (default=true).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.plot_network_plasticity-Tuple{Any, Any}","page":"API References","title":"SNNPlots.plot_network_plasticity","text":"plot_network_plasticity(model, simtime; interval = nothing, ΔT=1s, every=1)\n\nPlot the network activity with (raster plot and average firing rate_ and the synaptic weight dynamics\n\nArguments:\n- `model`: the model to plot\n- `simtime`: the simulation time object\n- `interval`: the interval to plot the firing rate and synaptic weight dynamics\n- `ΔT`: the time window to plot the raster plot\n- `every`: plot 1 out of `every` spikes in the raster plot\n\nIf `interval` is not provided, the function will plot the last 10 seconds of the simulation time\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.plot_weights-Tuple{Any}","page":"API References","title":"SNNPlots.plot_weights","text":"plot_weights(network)\n\nPlot the synaptic weights of:     - inhibitory to excitatory neurons     - correlation of synaptic weights between inhibitory and excitatory neurons     - distribution of firing rates of the network\n\nArguments\n\nnetwork: The spiking neural network object.\n\nReturns\n\nplot: The plot object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.soma_gplot-Tuple{Any}","page":"API References","title":"SNNPlots.soma_gplot","text":"soma_gplot( population, target; neuron=1, r, dt, param=:soma_syn, nmda=true, ax=plot(), kwargs...)\n\nPlot the synaptic current in the soma of a population of neurons.\nThe function uses the synaptic conductance and the membrane potential to calculate the synaptic current.\n\nParameters\n----------\npopulation : AbstractPopulation\n    The population of neurons to plot\nneuron : Int\n    The neuron to plot\nr : Array{Int}:\n    The time range to plot\nparam : Symbol\n    The parameter to use for the synaptic conductance\nax : Plots.Plot\n    Plot over the current axis\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.stdp_kernel-Tuple{Any}","page":"API References","title":"SNNPlots.stdp_kernel","text":"stdp_kernel(stdp_param; ΔT= -97.5:5:100ms)\n\nPlot the STDP kernel for the given STDP parameters. \n\n# Arguments\n- `stdp_param::STDPParameter`: STDP parameters\n- `ΔT::Array{Float32}`: Arrays of time differences between pre and post-synaptic spikes\n\n# Return\n- `Plots.Plot`: Plot of the STDP kernel\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.stp_plot","page":"API References","title":"SNNPlots.stp_plot","text":"stp_plot(model, interval, assemblies)\n\nPlot the activity of a spiking neural network with short-term plasticity. The function plots the membrane potential, the firing rate, the synaptic weights, and the raster plot of the excitatory population.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Other-types","page":"API References","title":"Other types","text":"","category":"section"},{"location":"api_reference/#SNNModels.AdditiveNorm","page":"API References","title":"SNNModels.AdditiveNorm","text":"AdditiveNorm{FT = Float32} <: NormParam\n\nThis struct holds the parameters for additive normalization.  It includes a timescale τ (default 0.0) and an operator (default addition).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Dendrite","page":"API References","title":"SNNModels.Dendrite","text":"Dendrite\n\nA structure representing a dendritic compartment within a neuron model.\n\nFields\n\nEr::FT = -70.6mV: Resting potential.\nC::FT = 10pF: Membrane capacitance.\ngax::FT = 10nS: Axial conductance.\ngm::FT = 1nS: Membrane conductance.\nl::FT = 150um: Length of the dendritic compartment.\nd::FT = 4um: Diameter of the dendrite.\n\nThe type FT represents Float32.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.EmptyParam","page":"API References","title":"SNNModels.EmptyParam","text":"EmptyParam\n\nA struct representing an empty parameter.\n\nFields\n\ntype::Symbol: The type of the parameter, default is :empty.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.GABAergic","page":"API References","title":"SNNModels.GABAergic","text":"GABAergic struct represents a group of GABAergic receptors.\n\nFields\n\nGABAa::T: GABAa receptor\nGABAb::T: GABAb receptor\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Glutamatergic","page":"API References","title":"SNNModels.Glutamatergic","text":"Glutamatergic struct represents a group of glutamatergic receptors.\n\nFields\n\nAMPA::T: AMPA receptor\nNMDA::T: NMDA receptor\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.MarkramSTPParameter","page":"API References","title":"SNNModels.MarkramSTPParameter","text":"MarkramSTPParameter{FT <: AbstractFloat} <: STPParameter\n\nThe model is based on refractoriness of the synaptic release process, which can be rephrased by stating that:\nThe fraction (U) of the synaptic efficacy used by an AP becomes instantaneously unavailable for subsequent use and recovers with a time constant of τD (τrec, depression). The fraction of available synaptic efficacy is termed `x.`  A facilitating mechanism is included in the model as a pulsed increase in U by each AP. The running value of U is referred to as u and U remains a parameter that applies to the first AP in a train. u decays with a single exponential, τF (facilitation), to its resting value U. The amount of synaptic efficacy enhanced by a action potential is assumed to be U(1-u).\nThe increase in the amplitude of the postsynaptic response is proportional to the product of u and x.\n\nThe actual implementation follows the equations described in Mongillo et al. (2008) for clarity.\n\nFields\n\nτD::FT: Time constant for depression (default: 200ms)\nτF::FT: Time constant for facilitation (default: 1500ms)\nU::FT: Maximum utilization of synaptic resources (default: 0.2)\nWmax::FT: Maximum synaptic weight (default: 1.0pF)\nWmin::FT: Minimum synaptic weight (default: 0.0pF)\n\nThis struct is used to configure the short-term plasticity dynamics in synaptic connections following the model described by Markram et al. (1998).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.MultiplicativeNorm","page":"API References","title":"SNNModels.MultiplicativeNorm","text":"MultiplicativeNorm{FT = Int32} <: NormParam\n\nThis struct holds the parameters for multiplicative normalization.  It includes a timescale τ (default 0.0) and an operator (default multiplication).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.NMDAVoltageDependency","page":"API References","title":"SNNModels.NMDAVoltageDependency","text":"NMDAVoltageDependency struct represents the voltage dependence of NMDA receptors.\n\nFields\n\nb::T: Voltage dependence factor (default: 3.36)\nk::T: Voltage dependence factor (default: -0.077)\nmg::T: Magnesium concentration (default: 1.0)\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.NormParam","page":"API References","title":"SNNModels.NormParam","text":"Abstract type for normalization parameters.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PlasticityVariables","page":"API References","title":"SNNModels.PlasticityVariables","text":"PlasticityVariables\n\nAn abstract type representing plasticity variables.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PoissonLayerParameter","page":"API References","title":"SNNModels.PoissonLayerParameter","text":"PoissonLayerParameter\n\nPoisson stimulus with rate defined for each cell in the layer. Each neuron of the 'N' Poisson population fires with 'rate'.\nThe connectivity is defined by the parameter 'ϵ'. Thus, the number of presynaptic neuronsconnected to the postsynaptic neuronsis 'N*ϵ'. Each post-synaptic cell receives rate: 'rate * N * ϵ'.\n\n# Fields\n- `rate::Vector{R}`: A vector containing the rate of the Poisson stimulus.\n- `N::Int32`: The number of neuronsin the layer.\n- `ϵ::Float32`: The fraction of presynaptic neuronsconnected to the postsynaptic neurons.\n- `active::Vector{Bool}`: A vector of booleans indicating if the stimulus is active.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PoissonStimulusFixed","page":"API References","title":"SNNModels.PoissonStimulusFixed","text":"PoissonStimulusFixed\n\nPoisson stimulus with fixed rate. The rate arrives to all the neuronstargeted\nby the stimulus.\n\n# Fields\n- `rate::Vector{R}`: A vector containing the rate of the Poisson stimulus.\n- `active::Vector{Bool}`: A vector of booleans indicating if the stimulus is active.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PoissonStimulusInterval","page":"API References","title":"SNNModels.PoissonStimulusInterval","text":"PoissonStimulusInterval\n\nPoisson stimulus with rate defined for each cell in the layer. Each neuron of the 'N' Poisson population fires with 'rate' in the intervals defined by 'intervals'.\n\n# Fields\n- `rate::Vector{R}`: A vector containing the rate of the Poisson stimulus.\n- `intervals::Vector{Vector{R}}`: A vector of vectors containing the intervals in which the Poisson stimulus is active.\n- `active::Vector{Bool}`: A vector of booleans indicating if the stimulus is active.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PoissonStimulusVariable","page":"API References","title":"SNNModels.PoissonStimulusVariable","text":"PoissonStimulusVariable\n\nPoisson stimulus with rate defined with a function.\n\n# Fields\n- `variables::Dict{Symbol,Any}`: A dictionary containing the variables for the function.\n- `rate::Function`: A function defining the rate of the Poisson stimulus.\n- `active::Vector{Bool}`: A vector of booleans indicating if the stimulus is active.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PostSpike","page":"API References","title":"SNNModels.PostSpike","text":"PostSpike\n\nA structure defining the parameters of a post-synaptic spike event.\n\nFields\n\nA::FT: Amplitude of the Post-Synaptic Potential (PSP).\nτA::FT: Time constant of the PSP.\n\nThe type FT represents Float32.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Receptor","page":"API References","title":"SNNModels.Receptor","text":"Receptor struct represents a synaptic receptor with parameters for reversal potential, rise time, decay time, and conductance.\n\nFields\n\nE_rev::T: Reversal potential (default: 0.0)\nτr::T: Rise time constant (default: -1.0)\nτd::T: Decay time constant (default: -1.0)\ng0::T: Maximum conductance (default: 0.0)\ngsyn::T: Synaptic conductance (default: calculated based on g0, τr, and τd)\nα::T: Alpha factor for the differential equation (default: calculated based on τr and τd)\nτr⁻::T: Inverse of rise time constant (default: calculated based on τr)\nτd⁻::T: Inverse of decay time constant (default: calculated based on τd)\nnmda::T: NMDA factor (default: 0.0)\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.STDPGerstner","page":"API References","title":"SNNModels.STDPGerstner","text":"Gerstner, W., Kempter, R., van Hemmen, J. L., & Wagner, H. (1996). A neuronal learning rule for sub-millisecond temporal coding. Nature, 383(6595), 76–78. https://doi.org/10.1038/383076a0\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.STDPMexicanHat","page":"API References","title":"SNNModels.STDPMexicanHat","text":"STDPMexicanHat{FT = Float32}\n\nThe STDP is defined such that integral of the kernel is zero. The STDP kernel is defined as:\n\n`` A x * exp(-x/sqrt(2)) ``\n\nwhere   ``A`` is the learning rate for post and pre-synaptic spikes, respectively, and ``x`` is the difference between the post and pre-synaptic traces.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.STDPSymmetric","page":"API References","title":"SNNModels.STDPSymmetric","text":"STDPSymmetric{FT = Float32}\n\nSymmetric STDP rules described in:\n`Structured stabilization in recurrent neural circuits through inhibitory synaptic plasticity` \nby Festa, D., Cusseddu, C, and Gjorgjieva, J. (2024).\n\nThe STDP is defined such that integral of the kernel is zero. The STDP kernel is defined as:\n\n`` (\frac{A_{post}}{1/\tau_{post}} * exp(-t/\tau_{post} - \frac{A_{pre}}{\tau_pre} * exp(-t/\tau_{pre}) ``\n\nwhere ``A_{post}`` and ``A_{pre}`` are the learning rates for post and pre-synaptic spikes, respectively, and ``\tau_{post}`` and ``\tau_{pre}`` are the time constants for post and pre-synaptic traces, respectively.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Spiketimes","page":"API References","title":"SNNModels.Spiketimes","text":"Spiketimes\n\nA type alias for a vector of vectors of Float32, representing spike times.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Time","page":"API References","title":"SNNModels.Time","text":"struct Time\nTime\n\nA mutable struct representing time.  A mutable struct representing time.\n\nFields\n\nt::Vector{Float32}: A vector containing the current time.\ntt::Vector{Int}: A vector containing the current time step.\ndt::Float32: The time step size.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.vSTDPParameter","page":"API References","title":"SNNModels.vSTDPParameter","text":"vSTDPParameter{FT = Float32} <: SpikingSynapseParameter\n\nContains parameters for the voltage-dependent Spike-Timing Dependent Plasticity (vSTDP) model.\n\nFields\n\nA_LTD::FT: Long Term Depression learning rate.\nA_LTP::FT: Long Term Potentiation learning rate.\nθ_LTD::FT: LTD threshold.\nθ_LTP::FT: LTP threshold.\nτu::FT: Time constant for the pre-synaptic spike trace.\nτv::FT: Time constant for the post-synaptic membrane trace.\nτx::FT: Time constant for the variable x.\nWmax::FT: Maximum synaptic weight.\nWmin::FT: Minimum synaptic weight.\nactive::Vector{Bool}: Flag to activate or deactivate the plasticity rule.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Helper-macros","page":"API References","title":"Helper macros","text":"","category":"section"},{"location":"api_reference/#SNNModels.@load_units-Tuple{}","page":"API References","title":"SNNModels.@load_units","text":"@load_units\nLoad all the units defined in the module into the current scope.\nThis macro generates a block of expressions that assign the unit constants\n    \nThe base units in the module are:\n- cm : centimeters\n- ms : milliseconds\n- kHz : kilohertz\n- mV : millivolts\n- pA : picoamperes\n- pF : picofarads\n- nS : nanosiemens\n- GΩ : gigaohms\n- uM : micromolar\n\nThe derived units in the module are obtained as multiple or division of the base units. \n\nThe standard integration time step is 0.125ms, which is used in the simulation.\n\n\n\n\n\n","category":"macro"},{"location":"api_reference/#SNNModels.@snn_kw-Tuple{Any}","page":"API References","title":"SNNModels.@snn_kw","text":"A minimal implementation of Base.@kwdef with default type parameter support\n\n\n\n\n\n","category":"macro"},{"location":"models_ext/#Models-Extensions","page":"Models Extensions","title":"Models Extensions","text":"","category":"section"},{"location":"models_ext/","page":"Models Extensions","title":"Models Extensions","text":"Users can define new concrete types of the three abstract models (AbstractPopulation, AbstractStimulus, and AbstractSynapse) to extend the functionality of the SpikingNeural Networks package.","category":"page"},{"location":"models_ext/","page":"Models Extensions","title":"Models Extensions","text":"New populations, stimuli, or synapses models can be added by users by defining new types.","category":"page"},{"location":"models_ext/#Adding-a-Population-Model","page":"Models Extensions","title":"Adding a Population Model","text":"","category":"section"},{"location":"models_ext/","page":"Models Extensions","title":"Models Extensions","text":"To add a new population model, users need to define a new concrete type that inherits from AbstractPopulation. The new population model should include the following:","category":"page"},{"location":"models_ext/","page":"Models Extensions","title":"Models Extensions","text":"Parameters: Define a new type for the parameters of the population model. This type should inherit from AbstractPopulationParameter.\nState Variables: Define the state variables of the population model. These variables should be included in the new type that inherits from AbstractPopulation.\nIntegration Function: Define a integrate(population::P, param::T, dt::Float32) where {P<:AbstractPopulation, T<:AbstractPopulationParameter} function to integrate the population model. This function should update the state variables of the population model at each time step.","category":"page"},{"location":"models_ext/#Current-based-IF","page":"Models Extensions","title":"Current-based IF","text":"","category":"section"},{"location":"models_ext/","page":"Models Extensions","title":"Models Extensions","text":"using SpikingNeuralNetworks\nusing Distributions\nSNN.@load_units\n\n# The macro @eval is used to define the new neuron model within the SNNModels module. It is equivalent to add a new file in the SNNModels.jl/src/populations directory. We strongly suggest this approach to avoid complications with the module system.\n@eval SNN.SNNModels begin\n\n    \"\"\"\n    Define the neuron model parameters.\n    Parameters are used at integration time to compute the equation update.\n    All parameters are optional. We strongly advise using SI units and default values.\n    \"\"\"\n    NeuronParameter\n    @snn_kw struct NeuronParameter <: AbstractPopulationParameter\n        # adex parameters\n        R::Float32 = 1f0GΩ\n        Er::Float32 = -70.6f0\n        Vt::Float32 = -50.4f0\n        up::Float32 = 0.1f0 * ms\n        τabs::Float32 = 0.1f0 * ms\n        τe::Float32 = 10f0ms\n        τi::Float32 = 10f0ms\n    end\n\n    \"\"\"\n    Define the neuron model.\n    The neuron model holds the parameters and state variables of the neuron.\n    The state variables are used to compute the equation update at integration time and can be recorded.\n\n    The entries:\n     - `param::NeuronParameter`: The parameters of the neuron model.\n     - `N::Int64`: The number of neurons in the population.\n     - `name::String`: The name of the neuron population.\n     - `id::String`: A unique identifier for the neuron population.\n     - `records::Dict{Symbol, Any}`: A dictionary to store recorded variables.\n    are compulsory\n    \"\"\"\n    Neuron\n\n    @snn_kw struct Neuron <: AbstractPopulation\n        param::NeuronParameter = NeuronParameter()\n        N::Int64 = 10\n        name::String= \"Neuron\"\n        id::String = randstring(12)\n        v::Vector{Float32} = ones(Float32, N)*-70.6f0  # Initial membrane potential\n        ge::Vector{Float32} = zeros(Float32, N)\n        gi::Vector{Float32} = zeros(Float32, N)\n        fire::Vector{Bool} = falses(N)\n        I::Vector{Float32} = zeros(Float32, N)\n        records::Dict{Symbol, Any} = Dict{Symbol, Any}()\n    end\n\n    \"\"\"\n    Integrate the neuron model.\n    The function integrate!(p::Neuron, param::NeuronParameter, dt::Float32) is mandatory for the a Population model\n    and is used to update the state variables of the neuron model at each time step.\n\n    The function must only define the integration step, the recordings are handled by the simulation engine. \n    The following present a good practice to implement the integration step:\n    - Use the `@unpack` macro to extract the state variables from the neuron model.\n    - Use the `@inbounds` macro to skip bounds checking for performance reasons.\n    - Update the state variables in a for loop over the number of neurons `N`.\n    - Update the state variables using the timestep `dt` and the parameters from `param`.\n\n    The macro `@inbounds` is used to skip bounds checking for performance reasons. It leads to segment faults if the indices are out of bounds.\n\n    The macro `@fastmath` is used to allow the compiler to use fast math operations, which may lead to slight inaccuracies but improves performance. We consider that in the context of biophysical networks this imprecisions are not critical.\n    \"\"\"\n    integrate!\n\n    function integrate!(p::Neuron, param::NeuronParameter, dt::Float32)\n        @unpack N, v, ge, gi, fire, I = p\n        @inbounds @fastmath for i in 1:N\n            if fire[i]\n                v[i] = param.Er\n                fire[i] = false\n            else\n                v[i] += dt*(param.Er - v[i] +\n                        (ge[i] - gi[i]) * param.R +\n                        I[i] * param.R )\n            end\n            ge[i] -= ge[i] / param.τe * dt\n            gi[i] -= gi[i] / param.τi * dt\n            if v[i] >= param.Vt\n                fire[i] = true\n                v[i] = 20*mV  # Reset membrane potential after firing\n            end\n        end\n    end\n    export Neuron, NeuronParameter, integrate!\nend\n\nimport SpikingNeuralNetworks: NeuronParameter, Neuron, CurrentNoiseParameter, CurrentStimulus, compose, sim!, monitor!, vecplot\n# validate_population_model(SNN.Neuron()) # This is only available in SNNModels v1.5.5\n\nparam = NeuronParameter()\nneuron = Neuron(param=param, N=1)\n# Create a withe noise input current\ncurrent_param = CurrentNoiseParameter(neuron.N; I_base = 0pA, I_dist = Normal(-50pA, 100pA))\ncurrent_stim = CurrentStimulus(neuron, :I, param = current_param)\n\nmonitor!(neuron, [:v, :fire, :ge, :gi, :I], sr = 2kHz)\nmodel = compose(; neuron, current_stim)\nsim!(; model, duration = 1000ms, pbar=true)\n\nvecplot(\n    neuron,\n    :v,\n    add_spikes = true,\n    ylabel = \"Membrane potential (mV)\",\n    # ylims = (-80, 10),\n    c = :black,\n)","category":"page"},{"location":"models_ext/#Adding-a-Stimulus-Model","page":"Models Extensions","title":"Adding a Stimulus Model","text":"","category":"section"},{"location":"models_ext/","page":"Models Extensions","title":"Models Extensions","text":"Thanks to the multidispatching the simulation loop will call the function that matches the population, stimulus, or connection type and its parameter. Thus we don't need to always define a new type, defining a new parameter and a function that specializes for it is sufficient to introduce a new behaviour.","category":"page"},{"location":"models_ext/","page":"Models Extensions","title":"Models Extensions","text":"Here we extend the PoissonStimulus<:AbstractStimulus adding a new PoissonRefractoryParameter<:AbstractStimulusParameter. We use the function PoissonLayer to create an input layer that stimulate the postsynaptic population with Poisson distributed spikes with a ΔT absolute refractory period. ","category":"page"},{"location":"models_ext/#Poisson-Stimulus-with-refractory-time","page":"Models Extensions","title":"Poisson Stimulus with refractory time","text":"","category":"section"},{"location":"models_ext/","page":"Models Extensions","title":"Models Extensions","text":"using SpikingNeuralNetworks\nusing Distributions\nSNN.@load_units\nusing ProtoStructs\n\n# The macro @eval is used to define the new neuron model within the SNNModels module. It is equivalent to add a new file in the SNNModels.jl/src/populations directory. We strongly suggest this approach to avoid complications with the module system.\n@eval SNN.SNNModels begin\n\n    \"\"\"\n    Define the Poisson refractory stimulus parameters.\n    Parameters are used at integration time to compute the equation update.\n    All parameters are optional. \n    \"\"\"\n    PoissonRefractoryParameter\n\n    @snn_kw struct PoissonRefractoryParameter <: PoissonStimulusParameter #{R} where {R<:Float32}\n    # @proto struct PoissonRefractoryParameter{R = Float32} \n        ΔT::Float32 = 2f0ms  # Absolute refractory period\n        N::Int = 100  # Number of neurons\n        rate::Float32 = 10Hz\n        last_spike::Vector{Float32} = zeros(Float32, N)  # Last spike time for each neuron\n        rates::Vector{Float32} = fill(rate, N)  # Firing rate for each neuron\n        p::Float32 = 0.1f0  # Fraction of neurons receiving the stimulus\n        μ::Float32 = 1f0  # Mean of the weight distribution\n        σ::Float32 = 0f0  # Standard deviation of the weight distribution\n        active::Vector{Bool} = [true]  # Active neurons\n    end\n\n    \"\"\"\n    Generate a Poisson stimulus with an absolute refractory period for a postsynaptic population.\n    \"\"\"\n    function stimulate!(\n        p::PoissonStimulus,\n        param::PoissonRefractoryParameter,\n        time::Time,\n        dt::Float32,\n    )\n        @unpack N, randcache, fire, neurons, colptr, W, I, g = p\n        @unpack rates, ΔT, last_spike = param\n        current_time = get_time(time)\n        rand!(randcache)\n        @inbounds @simd for j = 1:N\n            if (current_time - last_spike[j]) > ΔT && randcache[j] < rates[j] * dt\n                fire[j] = true\n                last_spike[j] = current_time\n                @fastmath @simd for s ∈ colptr[j]:(colptr[j+1]-1)\n                    g[I[s]] += W[s]\n                end\n            else\n                fire[j] = false\n            end\n        end\n    end\n    export PoissonRefractoryParameter, stimulate!\nend\n\nimport SpikingNeuralNetworks: PoissonLayer, PoissonRefractoryParameter, compose, sim!, monitor!, vecplot\n# validate_population_model(SNN.Neuron()) # This is only available in SNNModels v1.5.5\n\nneuron_param = SNN.IdentityParam()\nneuron = SNN.Identity(; param = neuron_param, N = 1, name = \"Identity Neuron\")\n\n# Create a withe noise input current\nstim_param = PoissonRefractoryParameter(N=1, ΔT = 20ms, p=1)\nstim = PoissonLayer(neuron, :g; param=stim_param)\n\nmonitor!(neuron, [:g, :fire], sr = 2kHz)\nmodel = compose(; neuron, stim)\nsim!(; model, duration = 100000ms, pbar=true)\n\nvecplot(\n    neuron,\n    :g,\n    neurons=1,\n    add_spikes = true,\n    ylabel = \"Membrane potential (mV)\",\n    xlims = (0, 1000ms),\n    # ylims = (-80, 10),\n    c = :black,\n)\n\nst = SNN.spiketimes(neuron)[1]\ndiff(st) |> x-> SNNPlots.histogram(x, bins=100)","category":"page"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Pages = [\"models.md\"]","category":"page"},{"location":"models/#Populations","page":"Models","title":"Populations","text":"","category":"section"},{"location":"models/#Types","page":"Models","title":"Types","text":"","category":"section"},{"location":"models/#SNNModels.AbstractPopulation","page":"Models","title":"SNNModels.AbstractPopulation","text":"AbstractPopulation\n\nAn abstract type representing a population. Any struct inheriting from this type must implement:\n\nMethods\n\nintegrate!(p::NeuronModel, param::NeuronModelParam, dt::Float32): Integrates the neuron model over a time step dt using the given parameters.\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.BallAndStick","page":"Models","title":"SNNModels.BallAndStick","text":"This is a struct representing a spiking neural network model that include two dendrites and a soma based on the adaptive exponential integrate-and-fire model (AdEx)\n\nFields\n\nt::VIT : tracker of simulation index [0] \nparam::AdExSoma : Parameters for the AdEx model.\nN::Int32 : The number of neurons in the network.\nd::VDT: Dendritic compartment parameters.\nv_s::VFT : Somatic membrane potential.\nw_s::VFT : Adaptation variables for each soma.\nv_d::VFT: Dendritic membrane potential for dendrite.\ng_s::MFT , g_d::MFT : Conductance of somatic and dendritic synapses.\nh_s::MFT, h_d::MFT  : Synaptic gating variables.\nfire::VBT : Boolean array indicating which neurons have fired.\nafter_spike::VFT : Post-spike timing.\npostspike::PST : Model for post-spike behavior.\nθ::VFT : Individual neuron firing thresholds.\nrecords::Dict : A dictionary to store simulation results.\nΔv::VFT , Δv_temp::VFT : Variables to hold temporary voltage changes.\ncs::VFT , is::VFT : Temporary variables for currents.\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.HH","page":"Models","title":"SNNModels.HH","text":"Hodgkin–Huxley Neuron\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.IF","page":"Models","title":"SNNModels.IF","text":"[Integrate-And-Fire Neuron](https://neuronaldynamics.epfl.ch/online/Ch1.S3.html)\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.IZ","page":"Models","title":"SNNModels.IZ","text":"Izhikevich Neuron\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.MorrisLecar","page":"Models","title":"SNNModels.MorrisLecar","text":"Morris-Lecar Neuron\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.Poisson","page":"Models","title":"SNNModels.Poisson","text":"Poisson Neuron\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.Rate","page":"Models","title":"SNNModels.Rate","text":"Rate Neuron\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.Tripod","page":"Models","title":"SNNModels.Tripod","text":"This is a struct representing a spiking neural network model that include two dendrites and a soma based on the adaptive exponential integrate-and-fire model (DendNeuronParameter)\n\nFields\n\nt::VIT : tracker of simulation index [0] \nparam::AdExSoma : Parameters for the AdEx model.\nN::Int32 : The number of neurons in the network.\nd1::VDT, d2::VDT : Dendrite structures.\nNMDA::NMDAT : Specifies the properties of NMDA (N-methyl-D-aspartate) receptors.\ngax1::VFT, gax2::VFT : Axial conductance (reciprocal of axial resistance) for dendrite 1 and 2 respectively.\ncd1::VFT, cd2::VFT : Capacitance for dendrite 1 and 2.\ngm1::VFT, gm2::VFT : Membrane conductance for dendrite 1 and 2.\nv_s::VFT : Somatic membrane potential.\nw_s::VFT : Adaptation variables for each soma.\nv_d1::VFT , v_d2::VFT : Dendritic membrane potential for dendrite 1 and 2.\ng_s::MFT , g_d1::MFT, g_d2::MFT : Conductance of somatic and dendritic synapses.\nh_s::MFT, h_d1::MFT, h_d2::MFT : Synaptic gating variables.\nfire::VBT : Boolean array indicating which neurons have fired.\nafter_spike::VFT : Post-spike timing.\npostspike::PST : Model for post-spike behavior.\nθ::VFT : Individual neuron firing thresholds.\nrecords::Dict : A dictionary to store simulation results.\nΔv::VFT , Δv_temp::VFT : Variables to hold temporary voltage changes.\ncs::VFT , is::VFT : Temporary variables for currents.\n\n\n\n\n\n","category":"type"},{"location":"models/#Parameters","page":"Models","title":"Parameters","text":"","category":"section"},{"location":"models/#SNNModels.AbstractPopulationParameter","page":"Models","title":"SNNModels.AbstractPopulationParameter","text":"AbstractPopulationParameter <: AbstractParameter\n\nAn abstract type representing a population parameter.\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.DendNeuronParameter","page":"Models","title":"SNNModels.DendNeuronParameter","text":"DendNeuronParameter{FT, IT, DT, ST, NMDAT, PST, PT}\n\nA parameter struct for the Tripod neuron model, implementing an Adaptive Exponential Integrate-and-Fire (AdEx) model with dendritic compartments.\n\nFields\n\nC::FT: Membrane capacitance (default: 281pF)\ngl::FT: Leak conductance (default: 40nS)\nR::FT: Total membrane resistance (default: nS/gl * GΩ)\nτm::FT: Membrane time constant (default: C/gl)\nEr::FT: Resting potential (default: -70.6mV)\nVr::FT: Reset potential (default: -55.6mV)\nVt::FT: Rheobase threshold (default: -50.4mV)\nΔT::FT: Slope factor (default: 2mV)\nτw::FT: Adaptation current time constant (default: 144ms)\na::FT: Subthreshold adaptation conductance (default: 4nS)\nb::FT: Spike-triggered adaptation increment (default: 80.5pA)\nAP_membrane::FT: After-potential membrane parameter (default: 10.0f0mV)\nBAP::FT: Backpropagating action potential parameter (default: 1.0f0mV)\nup::FT: Spike upstroke duration (default: 1ms)\nτabs::FT: Absolute refractory period (default: 2ms)\npostspike::PST: Post-spike dynamics (default: PostSpike(A=10, τA=30ms))\nds::DT: Dendritic segment lengths (default: [200um, (200um, 400um)])\nphysiology::PT: Dendritic physiology (default: human_dend)\nsoma_syn::ST: Soma synapse type (default: TripodSomaSynapse)\ndend_syn::ST: Dendritic synapse type (default: TripodDendSynapse)\nNMDA::NMDAT: NMDA voltage dependency parameters (default: NMDAVoltageDependency(mg=MgmM, b=nmdab, k=nmda_k))\n\nType Parameters\n\nFT: Floating-point type for membrane parameters (default: Float32)\nIT: Integer type for time-related parameters (default: Int64)\nDT: Type for dendritic segment lengths (default: Vector{DendLength})\nST: Synapse type (default: Synapse)\nNMDAT: NMDA voltage dependency type (default: NMDAVoltageDependency{Float32})\nPST: Post-spike dynamics type (default: PostSpike{Float32})\nPT: Physiology type (default: Physiology)\n\nExamples\n\njulia> TripodParameter = DendNeuronParameter(ds = [200um, (200um, 400um)])\nDendNeuronParameter{Float32, Int64, Vector{DendLength}, Synapse, NMDAVoltageDependency{Float32}, PostSpike{Float32}, Physiology}(281.0, 40.0, 25.0, 7.03125, -70.6, -55.6, -50.4, 2.0, 144.0, 4.0, 80.5, 10.0, 1.0, 1, 2, PostSpike{Float32}(10, 30.0), [200.0, (200.0, 400.0)], human_dend, TripodSomaSynapse, TripodDendSynapse, NMDAVoltageDependency{Float32}(0.001, 0.062, 3.57))\n\njulia> BallAndStickParameter = DendNeuronParameter(ds = [(150um, 400um)])\nDendNeuronParameter{Float32, Int64, Vector{DendLength}, Synapse, NMDAVoltageDependency{Float32}, PostSpike{Float32}, Physiology}(281.0, 40.0, 25.0, 7.03125, -70.6, -55.6, -50.4, 2.0, 144.0, 4.0, 80.5, 10.0, 1.0, 1, 2, PostSpike{Float32}(10, 30.0), [(150.0, 400.0)], human_dend, TripodSomaSynapse, TripodDendSynapse, NMDAVoltageDependency{Float32}(0.001, 0.062, 3.57))\n\n\n\n\n\n","category":"type"},{"location":"models/#Synapses","page":"Models","title":"Synapses","text":"","category":"section"},{"location":"models/#SNNModels.AbstractConnection","page":"Models","title":"SNNModels.AbstractConnection","text":"AbstractConnection\n\nAn abstract type representing a connection. Any struct inheriting from this type must implement:\n\nMethods\n\nforward!(c::Synapse, param::SynapseParameter): Propagates the signal through the synapse.\nplasticity!(c::Synapse, param::SynapseParameter, dt::Float32, T::Time): Updates the synapse parameters based on plasticity rules.\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.AbstractNormalization","page":"Models","title":"SNNModels.AbstractNormalization","text":"AbstractNormalization <: AbstractConnection\n\nAn abstract type representing a normalization connection.\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.AbstractSparseSynapse","page":"Models","title":"SNNModels.AbstractSparseSynapse","text":"AbstractSparseSynapse <: AbstractConnection\n\nAn abstract type representing a sparse synapse connection.\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.AggregateScaling-Tuple{Any, Any}","page":"Models","title":"SNNModels.AggregateScaling","text":"SynapseNormalization(N; param, kwargs...)\n\nConstructor function for the SynapseNormalization struct.\n\nN: The number of synapses.\nparam: Normalization parameter, can be either MultiplicativeNorm or AdditiveNorm.\nkwargs: Other optional parameters.\n\nReturns a SynapseNormalization object with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"models/#SNNModels.FLSparseSynapse","page":"Models","title":"SNNModels.FLSparseSynapse","text":"Force Learning Sparse Synapse\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.FLSynapse","page":"Models","title":"SNNModels.FLSynapse","text":"Force Learning Full Synapse\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.PINningSparseSynapse","page":"Models","title":"SNNModels.PINningSparseSynapse","text":"PINing Sparse Synapse\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.PINningSynapse","page":"Models","title":"SNNModels.PINningSynapse","text":"PINing Sparse Synapse\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.RateSynapse","page":"Models","title":"SNNModels.RateSynapse","text":"Rate Synapse\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.SpikeRateSynapse","page":"Models","title":"SNNModels.SpikeRateSynapse","text":"Rate Synapse\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.SpikingSynapse","page":"Models","title":"SNNModels.SpikingSynapse","text":"SpikingSynapse to connect neuronal populations\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.SynapseNormalization","page":"Models","title":"SNNModels.SynapseNormalization","text":"SynapseNormalization{VFT = Vector{Float32}, VIT = Vector{Int32}, MFT = Matrix{Float32}}\n\nA struct that holds parameters for synapse normalization, including:\n\nparam: Normalization parameter, can be either MultiplicativeNorm or AdditiveNorm.\nt: A vector of integer values representing time points.\nW0: A vector of initial weights before simulation.\nW1: A vector of weights during the simulation.\nμ: A vector of mean synaptic weights.\nrecords: A dictionary for storing additional data.\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.SynapseNormalization-Tuple{Any, Any}","page":"Models","title":"SNNModels.SynapseNormalization","text":"SynapseNormalization(N; param, kwargs...)\n\nConstructor function for the SynapseNormalization struct.\n\nN: The number of synapses.\nparam: Normalization parameter, can be either MultiplicativeNorm or AdditiveNorm.\nkwargs: Other optional parameters.\n\nReturns a SynapseNormalization object with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"models/#Plasticity","page":"Models","title":"Plasticity","text":"","category":"section"},{"location":"models/#Stimuli","page":"Models","title":"Stimuli","text":"","category":"section"},{"location":"models/#Types-2","page":"Models","title":"Types","text":"","category":"section"},{"location":"models/#SNNModels.AbstractStimulus","page":"Models","title":"SNNModels.AbstractStimulus","text":"AbstractStimulus\n\nAn abstract type representing a stimulus. Any struct inheriting from this type must implement:\n\nMethods\n\nstimulate!(p::Stimulus, param::StimulusParameter, time::Time, dt::Float32): Applies the stimulus to the population.\n\n\n\n\n\n","category":"type"},{"location":"models/#SNNModels.BalancedStimulus-Union{Tuple{R}, Tuple{T}, Tuple{T, Symbol, Symbol}, Tuple{T, Symbol, Symbol, Any}} where {T<:SNNModels.AbstractPopulation, R<:Real}","page":"Models","title":"SNNModels.BalancedStimulus","text":"BalancedStimulus(post::T, sym::Symbol, r::Union{Function, Float32}, neurons=[]; N_pre::Int=50, p_post::R=0.05f0, μ::R=1.f0, param=BalancedParameter()) where {T <: AbstractPopulation, R <: Number}\n\nConstructs a BalancedStimulus object for a spiking neural network.\n\nArguments\n\npost::T: The target population for the stimulus.\nsym::Symbol: The symbol representing the synaptic conductance or current.\nr::Union{Function, Float32}: The firing rate of the stimulus. Can be a constant value or a function of time.\nneurons=[]: The indices of the neuronsin the target population that receive the stimulus. If empty, neuronsare randomly selected based on the probability p_post.\nN::Int=200: The number of Balanced neurons neurons.\nN_pre::Int=5: The number of presynaptic connected.\np_post::R=0.05f0: The probability of connection between presynaptic and postsynaptic neurons.\nμ::R=1.f0: The scaling factor for the synaptic weights.\nparam=BalancedParameter(): The parameters for the Balanced distribution.\n\nReturns\n\nA BalancedStimulus object.\n\n\n\n\n\n","category":"method"},{"location":"models/#SNNModels.AbstractStimulusParameter","page":"Models","title":"SNNModels.AbstractStimulusParameter","text":"AbstractStimulusParameter <: AbstractParameter\n\nAn abstract type representing a stimulus parameter.\n\n\n\n\n\n","category":"type"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The library allows us to define and simulate models from computational neuroscience easily. The library exposes two functions:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"function sim!(p::Vector{AbstractPopulation}, c::Vector{AbstractConnection}, duration<:Real) end function train!(p::Vector{AbstractConnection}, c:Vector{AbstractConnection}, duration<:Real) end The functions support simulation with and without neural plasticity; the model is defined within the arguments passed to the functions. Models are composed of 'AbstractPopulation' and 'AbstractConnection' arrays.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Any elements of AbstractPopulation must implement the method:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"function integrate!(p, p.param, dt) end Conversely, elements of AbstractConnection must implement the methods:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"function forward!(p, p.param) end function plasticity!(c, c.param, dt) end The library is rich in examples of common neuron models that can be used as a basis.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In the notebook folder, there is a tutorial about how to use SparseMatrices in the SNN framework.","category":"page"},{"location":"examples/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"examples/#AdEx-neuron","page":"Tutorial","title":"AdEx neuron","text":"","category":"section"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"A single neuron under a fixed depolaring current can be modeled with an Adaptive Exponential model, with equations:","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"beginaligned\ntau_m fracdVdt =  (V^s-V_r) + Delta_T expfracV^s-V_tDelta_T - R (w + I) \ntau_wfracdwdt = -w + a (V^s-V_r) + b cdot delta(t-t_spike)\nendaligned","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"This model is implemented in the AdEx neuron model. The AdEx model can reproduce several different firing patterns observed in real neurons under direct current injections in the soma (AdEx firing patterns, Adaptive exponential integrate-and-fire model as an effective description of neuronal activity).  ","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"using SNNPlots\nimport SNNPlots: vecplot, plot\nusing SpikingNeuralNetworks\nusing DataFrames\nSNN.@load_units\n\n# Define the data\ndata = [\n    (\"Tonic\", 20, 0.0, 30.0, 60.0, -55.0, 65),\n    (\"Adapting\", 20, 0.0, 100.0, 5.0, -55.0, 65),\n    (\"Init. burst\",  5.0, 0.5, 100.0, 7.0, -51.0, 65),\n    (\"Bursting\",  5.0, -0.5, 100.0, 7.0, -46.0, 65),\n    # (\"Irregular\", 14.4, -0.5, 100.0, 7.0, -46.0, 65),\n    (\"Transient\", 10, 1.0, 100, 10.0, -60.0, 65),\n    (\"Delayed\", 5.0, -1.0, 100.0, 10.0, -60., 25)\n]\n\n\n\n# Create the DataFrame\ndf = DataFrame(\n    Type = [row[1] for row in data],\n    τm = [row[2] for row in data],\n    a = [row[3] for row in data],\n    τw = [row[4] for row in data],\n    b = [row[5] for row in data],\n    ur = [row[6] for row in data],\n    i = [row[7] for row in data]\n)\n\n# Display the DataFrame","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"Row Type τm a τw b ur i\n1 Tonic 20 0.0 30.0 60.0 -55.0 65\n2 Adapting 20 0.0 100.0 5.0 -55.0 65\n3 Init. burst 5.0 0.5 100.0 7.0 -51.0 65\n4 Bursting 5.0 -0.5 100.0 7.0 -46.0 65\n5 Irregular 14.4 -0.5 100.0 7.0 -46.0 65\n6 Transient 10 1.0 100 10.0 -60.0 65\n7 Delayed 5.0 -1.0 100.0 10.0 -60.0 25","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"plots = map(eachrow(df)) do row\n    param = AdExParameter(\n        R = 0.5GΩ,\n        Vt = -50mV,\n        ΔT = 2mV,\n        El = -70mV,\n        # τabs=0,\n        τm = row.τm * ms,\n        Vr = row.ur * mV,\n        a = row.a * nS,\n        b= row.b * pA,\n        τw = row.τw * ms,\n        At = 0f0\n    )\n\n\n    E = SNN.AdEx(; N = 1, \n        param,\n        )\n    SNN.monitor!(E, [:v, :fire, :w], sr = 8kHz)\n    model = compose(; E = E, silent=true)\n\n    E.I .= Float32(05pA)\n    SNN.sim!(; model, duration = 30ms)\n    E.I .= Float32(row.i)\n    # E.I .= row.i, # Current step\n    SNN.sim!(; model, duration = 300ms)\n\n    default(color=:black)\n    p1 = plot(vecplot(E, :w, ylabel=\"Adapt. current (nA)\"), \n            vecplot(E, :v, add_spikes=true, ylabel=\"Membrane potential (mV)\", ylims=(-80, 10)), \n            title = row.Type,\n            layout = (1,2), \n            size = (600, 800), \n            margin=10Plots.mm)\nend\n\nplot(plots...,  \n    layout = (7, 1), \n    size = (800, 2000), \n    xlabel=\"Time (ms)\", \n    legend=:outerright,\n    leftmargin=15Plots.mm,\n)","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Firing patterns of AdEx neuron)","category":"page"},{"location":"examples/#Noise-input-current","page":"Tutorial","title":"Noise input current","text":"","category":"section"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"In 'in vivo' experiments neurons are driven with noisy inputs that can be modeled by splitting the input current in two components I = Iˆdet(t) + I^noise(t).","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"the neuronal dynamics is then determined (for a generalized Leaky and Integrate model) by the equation:","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"tau_m fracd u d t = f(u) + R I^det(t) + R I^noise(t)","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"In this description the I^noise(t) is the stochastic component of the external current, which is normally assumed to be a white noise.  Under white noise, the average value of the external current is langle I_noise rangle = 0 and the autocorrelation is determined by the neuronal timescale and the noise variance, langle I^noise(t) I^noise(t) rangle = tau_m sigma delta (t-t).","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"To introduce white noise in the model we can use the CurrentNoiseParameter type. In the following example:","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"define a Leaky Integrate-and-Fire neuron ;\ndefine a CurrentNoiseParameter, it accepts a I_base value (the deterministic current) and a distribution, which we set to be a Normal distribution with zero average and 100pA variance;\nCurrentStimulus attaches an <: AbstraactStimulus to the :I variable of the population E;\nrecord the variables, simulate and plot the results.","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"\nimport SNNPlots: vecplot, plot\nusing SpikingNeuralNetworks\nusing Distributions\nSNN.@load_units\n\nif_parameter = SNN.IFParameter(\n    R = 0.5GΩ,\n    Vt = -50mV,\n    ΔT = 2mV,\n    El = -70mV,\n    τm = 20ms,\n    Vr = -55mV,\n)\n\n# Create the IF neuron with tonic firing parameters\nE = SNN.IF(; N = 1, \n    param=if_parameter,\n    )\nSNN.monitor!(E, [:v, :fire, :w, :I], sr = 2kHz)\n\n# Create a withe noise input current \ncurrent_param = CurrentNoiseParameter(E.N; I_base=30pA, I_dist=Normal(00pA, 100pA))\ncurrent = CurrentStimulus(E, :I, param=current_param)\nmodel = compose(; E = E, I=current)\nSNN.sim!(; model, duration = 2000ms)\n\np = plot(\n    vecplot(E, :v, add_spikes=true, ylabel=\"Membrane potential (mV)\", ylims=(-80, 10), c=:black),\n    vecplot(E, :I, ylabel=\"External current (pA)\", c=:gray, lw=0.4, alpha=0.4),\n    layout=(\n        2, 1\n    ),\n    size=(600, 500),\n    xlabel= \"Time (s)\",\n    leftmargin=10Plots.mm,\n)\n","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Noise input current)","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"The library also allows to define an arbitrary complex noise function with the CurrentVariableParameter type. In this case we must define a function, in this case sinusoidal_current, which is called runtime to determine the input current to each neuron in the population, the function must accept three arguments: ","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"a dictionary with the variables::Dict;\nthe time of the model t::Float32;\nthe index of the neuron i::Int32.","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"We thus define the set of variables that the function uses to determine the current and pass them along the function to CurrentVariableParameter. ","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"In the following example we used a plain sinusoidal current that stimulate the two neurons in the population with a phase a frequency of 1Hz and a phase shift of 3/4 π","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"\n\n# Create a populations with 2 IF neurons\nE = SNN.IF(; N = 2, \n    param=if_parameter,\n    )\nSNN.monitor!(E, [:v, :fire, :w, :I], sr = 2kHz)\n\n# Create a withe noise input current \n\nfunction sinusoidal_current(variables::Dict, t::Float32, i::Int)\n    # Extract the parameters from the variables dictionary\n    amplitude = variables[:amplitude]\n    frequency = variables[:frequency]\n    phase = variables[:shift_phase]\n    \n    # Calculate the current value at time t for neuron i\n    return amplitude * sin(2 * π * frequency * t + i*phase)\nend\n\nvariables = Dict(\n    :amplitude => 50pA,\n    :frequency => 1Hz,\n    :shift_phase => π*3/4, # Phase shift for each neuron\n)\n\ncurrent_param = SNN.CurrentVariableParameter(variables, sinusoidal_current )\ncurrent = CurrentStimulus(E, :I, param=current_param)\nmodel = compose(; E = E, I=current)\nSNN.sim!(; model, duration = 2000ms)\n\np = plot(\n    vecplot(E, :v, add_spikes=true, ylabel=\"Membrane potential (mV)\", ylims=(-80, 10)),\n    vecplot(E, :I, ylabel=\"External current (pA)\", c=:gray, lw=0.4, alpha=0.4),\n    layout=(\n        2, 1\n    ),\n    size=(600, 500),\n    xlabel= \"Time (s)\",\n    leftmargin=10Plots.mm,\n)\n","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Variable input current)","category":"page"},{"location":"examples/#Balanced-input-spikes","page":"Tutorial","title":"Balanced input spikes","text":"","category":"section"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"In biophysical networks, and in the brain, neurons' membrane potential is not driven by external currents but by the opening and closing of ionic channels following an afferent spike. Spikes cause the release of vescicles in the synaptic cleft that bind to the ionic channels on the post-synaptic neuron's membrane.  The opening of a ionic channel can lead to a depolarizing or hyperpolarizing current, dependently on its reversal potential. ","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"In this example we use two spike trains, an excitatory and an inhibitory one, to stimulate a Leaky Integrate-and-Fire neuron above the spike-threshold. The large number of spikes received increases the synaptic conductance of the cell, to the point that it dominates over the leakage conductance term. In this condition, the neurons membrane dynamics is dominated by the external inputs, and the neuron is in the so-called \"High-conductance state\". ","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"using SpikingNeuralNetworks\nusing SNNPlots\nimport SNNPlots: vecplot, plot, savefig, gplot\nSNN.@load_units\n\nif_parameter = SNN.IFParameter(\n    R = 0.5GΩ,\n    Vt = -50mV,\n    ΔT = 2mV,\n    El = -70mV,\n    τm = 20ms,\n    Vr = -55mV,\n    E_i = -75mV,\n    E_e = 0mV,\n)\n\n# Create the IF neuron\n# E = SNN.AdEx(; N = 1, \n#     # param=if_parameter,\n#     )\nE = SNN.IF(; N = 1, \n    param=if_parameter,\n    )\n\n# Create an excitatory and inhibitory spike trains\n\n# Define the Poisson stimulus parameters \npoisson_exc = SNN.PoissonLayerParameter(\n    1.2Hz,    # Mean firing rate (Hz) \n    p = 1f0,  # Probability of connecting to a neuron\n    μ = 1.0,  # Synaptic strength (nS)\n    N = 1000, # Neurons in the Poisson Layer\n)\n\npoisson_inh = SNN.PoissonLayerParameter(\n    3Hz,       # Mean firing rate (Hz)\n    p = 1f0,   # Probability of connecting to a neuron\n    μ = 4.0,   # Synaptic strength (nS)\n    N = 1000,  # Neurons in the Poisson Layer\n)\n\n# Create the Poisson layers for excitatory and inhibitory inputs\nstim_exc = PoissonLayer(E, :ge, param=poisson_exc, name=\"noiseE\")\nstim_inh = PoissonLayer(E, :gi, param=poisson_inh, name=\"noiseI\")\n\n# Create the model and run the simulation\nmodel = compose(; E = E, stim_exc, stim_inh)\nSNN.monitor!(E, [:v, :fire, :w, :ge, :gi], sr = 2kHz)\nSNN.monitor!(model.stim, [:fire])\nSNN.sim!(; model, duration = 1000ms)\n\n# Plot the results\n# gplot is a special function the plots the synaptic currents\n\nSNNPlots.default(palette=:okabe_ito)\np = plot(\n    raster(model.stim),\n    gplot(E, v_sym=:v, ge_sym=:ge, gi_sym=:gi, \n        Ee_rev=0mV, Ei_rev=-75mV,\n        ylabel=\"Synapti current (μA)\"),\n    vecplot(E, :v, add_spikes=true, ylabel=\"Membrane potential (mV)\", ylims=(-80, 10), c=:black),\n    layout=(\n        3, 1\n    ),\n    fgcolorlegend=:transparent,\n    size=(800, 900),\n    xlabel= \"Time (s)\",\n    leftmargin=10SNNPlots.Plots.mm,\n)","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Poisson input)","category":"page"},{"location":"examples/#Ball-and-Stick-neuron","page":"Tutorial","title":"Ball and Stick neuron","text":"","category":"section"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"We can also implement more complex cellular models. A classical extension of the single-compartment cell, or point-neuron, is the ball-and-stick neuron. This model has a passive dendritic compartment and an active, non-linear soma.  In our case, the dendritic compartment can be endowed with synaptic non-linearities, such as the NMDA receptor voltage-dependence. The following example implements a ball and stick model with a steep dendritic non-linearity. The cell is stimulated with balanced excitatory-inhibitory inputs on the denrite.","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"using SpikingNeuralNetworks\nusing Plots\nusing Random\nSNN.@load_units\nimport SpikingNeuralNetworks: Synapse, Receptor, Glutamatergic, GABAergic, DendNeuronParameter, synapsearray, get_time\n\nusing BenchmarkTools\n\nRandom.seed!(1234)\n## Define the neuron model parameters\n# Define the synaptic properties for the soma and dendrites\nSomaSynapse = Synapse(\n    AMPA = Receptor(E_rev = 0.0, \n                    τr = 0.26, \n                    τd = 2.0, \n                    g0 = 0.73),\n    GABAa = Receptor(E_rev = -70.0, \n                     τr = 0.1, \n                     τd = 15.0, \n                     g0 = 0.38)\n    # SomaSynapse has not NMDA and GABAb receptors, \n    # they are assigned to a NullReceptor and skipped at simulation time\n)\n\nDendSynapse = Synapse(\n    AMPA = Receptor(E_rev = 0.0, τr = 0.26, τd = 2.0, g0 = 0.73),\n    NMDA = Receptor(E_rev = 0.0, τr = 8, τd = 35.0, g0 = 1.31, nmda = 1.0f0),\n    GABAa = Receptor(E_rev = -70.0, τr = 4.8, τd = 29.0, g0 = 0.27),\n    GABAb = Receptor(E_rev = -90.0, τr = 30, τd = 400.0, g0 = 0.0006), \n)\n\nNMDA = let\n    Mg_mM = 1.0mM\n    nmda_b = 3.36   # voltage dependence of nmda channels\n    nmda_k = -0.077     # Eyal 2018\n    SNN.NMDAVoltageDependency(mg = Mg_mM/mM, b = nmda_b, k = nmda_k)\nend\n\n# We then define the dendritic neuron model. The dendritic neuron holds has the soma and dendritic compartments parameters, and the synaptic properties for both compartments. \ndend_neuron = DendNeuronParameter(\n    # adex parameters\n    C = 281pF,\n    gl = 40nS,\n    Vr = -55.6,\n    Er = -70.6,\n    ΔT = 2,\n    Vt = -50.4,\n    a = 4,\n    b = 80.5pA,\n    τw = 144,\n    up = 0.1ms,\n    τabs = 0.1ms,\n\n    # post-spike adaptation\n    postspike = SNN.PostSpike(A= 10.0, τA= 30.0), \n\n    # synaptic properties\n    soma_syn = SomaSynapse,\n    dend_syn = DendSynapse,\n    NMDA = NMDA,\n\n    # dendrite\n    ds = [160um],\n    physiology = SNN.human_dend,\n)\n\nE = SNN.SNNModels.BallAndStick(N=1, param = dend_neuron)\n\npoisson_exc = SNN.PoissonLayerParameter(\n    10.2Hz,    # Mean firing rate (Hz) \n    p = 1f0,  # Probability of connecting to a neuron\n    μ = 1.0,  # Synaptic strength (nS)\n    N = 1000, # Neurons in the Poisson Layer\n)\n\npoisson_inh = SNN.PoissonLayerParameter(\n    3Hz,       # Mean firing rate (Hz)\n    p = 1f0,   # Probability of connecting to a neuron\n    μ = 4.0,   # Synaptic strength (nS)\n    N = 1000,  # Neurons in the Poisson Layer\n)\n\n# Create the Poisson layers for excitatory and inhibitory inputs\nstim_exc = SNN.PoissonLayer(E, :glu, :d, param=poisson_exc, name=\"noiseE\")\nstim_inh = SNN.PoissonLayer(E, :gaba, :d, param=poisson_inh, name=\"noiseI\")\n\nmodel = SNN.compose(;E, stim_exc, stim_inh)\nSNN.monitor!(E, [:v_s, :v_d, :fire, :g_s, :g_d], sr=1000Hz)\n\n#\nPlots.default(palette = :okabe_ito)\nSNN.sim!(model, 3s)\np = SNN.vecplot(E, :v_d, sym_id=1, interval=1:2ms:get_time(model), neurons=1, label=\"Dendritic Compartment\")\nSNN.vecplot!(p, E, :v_s, sym_id=2, interval=1:2ms:get_time(model), neurons=1, add_spikes=true, label=\"Soma Compartment\")\nplot!(ylims=:auto, legend=:outertop, legendfontsize=12, xlabel=\"Time (s)\", ylabel=\"Voltage (mV)\", title=\"Ball and Stick Neuron Model\")","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Ball-and-Stick)","category":"page"},{"location":"examples/#Recurrent-EI-network","page":"Tutorial","title":"Recurrent EI network","text":"","category":"section"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"using DrWatson\nusing Plots\nusing UnPack\nusing SpikingNeuralNetworks\nSNN.@load_units\n##\n\nZerlaut2019_network = (Npop = (E=8000, I=2000),\n    exc = IFSinExpParameter(\n                τm = 200pF / 10nS, \n                El = -70mV, \n                Vt = -50.0mV, \n                Vr = -70.0f0mV,\n                R  = 1/10nS, \n                τabs = 2ms,       \n                τi=5ms,\n                τe=5ms,\n                E_i = -80mV,\n                E_e = 0mV,\n                ),\n\n    inh = IFSinExpParameter(\n                τm = 200pF / 10nS, \n                El = -70mV, \n                Vt = -53.0mV, \n                Vr = -70.0f0mV,\n                R  = 1/10nS, \n                τabs = 2ms,       \n                τi=5ms,\n                τe=5ms,\n                E_i = -80mV,\n                E_e = 0mV,\n                ),\n\n    connections = (\n        E_to_E = (p = 0.05, μ = 2nS),\n        E_to_I = (p = 0.05, μ = 2nS),\n        I_to_E = (p = 0.05, μ = 10nS),\n        I_to_I = (p = 0.05, μ = 10nS),\n        ),\n    \n    afferents = (\n        N = 100,\n        p = 0.1f0,\n        rate = 20Hz,\n        μ = 4.0,\n        ), \n)\n\nfunction network(config)\n    @unpack afferents, connections, Npop = config\n    E = IF(N=Npop.E, param=config.exc, name=\"E\")\n    I = IF(N=Npop.I, param=config.inh, name=\"I\")\n\n    AfferentParam = PoissonLayerParameter(afferents.rate; afferents...)\n    afferentE = PoissonLayer(E, :ge, param=AfferentParam, name=\"noiseE\")\n    afferentI = PoissonLayer(I, :ge, param=AfferentParam, name=\"noiseI\")\n\n    synapses = (\n        E_to_E = SpikingSynapse(E, E, :ge, p=connections.E_to_E.p, μ=connections.E_to_E.μ, name=\"E_to_E\"),\n        E_to_I = SpikingSynapse(E, I, :ge, p=connections.E_to_I.p, μ=connections.E_to_I.μ, name=\"E_to_I\"),\n        I_to_E = SpikingSynapse(I, E, :gi, p=connections.I_to_E.p, μ=connections.I_to_E.μ, name=\"I_to_E\"),\n        I_to_I = SpikingSynapse(I, I, :gi, p=connections.I_to_I.p, μ=connections.I_to_I.μ, name=\"I_to_I\"),\n    )\n    model = compose(;E,I, afferentE, afferentI, synapses..., silent=true, name=\"Balanced network\") \n    monitor!(model.pop, [:fire])\n    monitor!(model.stim, [:fire])\n    # monitor!(model.pop, [:v], sr=200Hz)\n    return compose(;model..., silent=true)\nend\n\n\n##\nplots = map([4, 10]) do input_rate\n    config = @update Zerlaut2019_network begin\n        afferents.rate = input_rate*Hz\n    end \n    model = network(config)\n    sim!(;model, duration=10_000ms,  pbar=true)\n    pr= raster(model.pop, every=40)\n\n    # Firing rate of the network with a fixed afferent rate\n    frE, r = firing_rate(model.pop.E, interval=3s:10s, pop_average=true)\n    frI, r = firing_rate(model.pop.I, interval=3s:10s, pop_average=true)\n    pf = plot(r, [frE, frI], labels=[\"E\" \"I\"],\n        xlabel=\"Time (s)\", ylabel=\"Firing rate (Hz)\", \n        title=\"Afferent rate: $input_rate Hz\",\n        size=(600, 400), lw=2)\n\n    # Plot the raster plot of the network\n    plot(pf, pr, layout=(2, 1))\nend\n\nplot(plots..., layout=(1,2), size=(1200, 600), xlabel=\"Time (s)\", leftmargin=10Plots.mm)\n##","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Recurrent network)","category":"page"},{"location":"examples/#FORCE-learning","page":"Tutorial","title":"FORCE learning","text":"","category":"section"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"An example of a rate-based spiking neural network (SNN) that implements the force learning algorithm described  \"Generating Coherent Patterns of Activity from Chaotic Neural Networks\" by D. Sussillo and L.F. Abbott (2009). The network consists of a 200 rate units with force learning synapses. The network is trained on a sinusoidal input signal for a certain duration, and then tested on the same signal. The plot shows the input signal and the network's prediction.","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"\nusing SpikingNeuralNetworks\nSNN.@load_units\nusing Plots\n\nS = SNN.Rate(; N = 200)\nSS = SNN.FLSynapse(S, S; μ = 1.5, p = 1.0)\nmodel = SNN.compose(; S, SS)\n\nSNN.monitor!(SS, [:f, :z], sr = 1000Hz)\n\nA = 1.3 / 1.5;\nfr = 1 / 60ms;\nf(t) =\n    (A / 1.0) * sin(1π * fr * t) +\n    (A / 2.0) * sin(2π * fr * t) +\n    (A / 6.0) * sin(3π * fr * t) +\n(A / 3.0) * sin(4π * fr * t)\n\n\nfor t = 0:0.125ms:2440ms\n    SS.f = f(t)\n    SNN.train!(; model, duration = 0.125f0)\nend\n\nfor t = 2440ms:0.125ms:3500ms\n    SS.f = f(t)\n    SNN.sim!(; model, duration = 0.125f0)\nend\n\n#\np = plot([SNN.getrecord(SS, :f) SNN.getrecord(SS, :z)], label = [\"Signal\" \"Prediction\"], lw = 3);\nplot!(p, xlabel = \"Time (ms)\", ylabel = \"Signal\", title = \"Force Learning Network\",\n      legend = :outerright, size = (800, 400), grid = false, ylims = (-1.8, 1.5), xlims =(2000, 3000), \n      fg_legend=:transparent, legendfontsize=14)\nannotate!(p, [(2240ms, -1.5, \"Training phase\")], textsize = 10, color = :black)\nannotate!(p, [(2650ms, -1.5, \"Testing phase\")], textsize = 10, color = :black)\n\nSS.records\n\nSS.records[:f]\n\nvline!([2440ms], color = :black, label = \"\", lw=3)","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Force Learning)","category":"page"},{"location":"examples/#STDP-with-homeostatic-plasticity","page":"Tutorial","title":"STDP with homeostatic plasticity","text":"","category":"section"},{"location":"examples/#Recurrent-network-with-dendrites","page":"Tutorial","title":"Recurrent network with dendrites","text":"","category":"section"},{"location":"examples/#Working-memory-with-synaptic-plasticity","page":"Tutorial","title":"Working memory with synaptic plasticity","text":"","category":"section"},{"location":"visualization/#Plots","page":"Plots","title":"Plots","text":"","category":"section"},{"location":"recordings/#Recordings","page":"Recordings","title":"Recordings","text":"","category":"section"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"One of the strengths of the SpikingNeuralNetworks.jl library is its easy access to all network variables. You can record any dynamic variable used at runtime, and to optimize memory usage, recordings can be subsampled.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"To demonstrate how recordings work, let’s instantiate a network model with excitatory and inhibitory recurrent connections. Excitatory connections follow short-term plasticity (STP), while inhibitory connections use long-term plasticity (LTP). We will show how to record different types of variables simulated in the network.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"using SpikingNeuralNetworks\nusing Statistics\nSNN.@load_units\n\n# AdEx neuron with fixed external current connections with multiple receptors\nE = SNN.AdEx(; N = 800, param = SNN.AdExParameter(; El = -50mV))\nI = SNN.IF(; N = 200, param = SNN.IFParameter())\nEE = SNN.SpikingSynapse(E, E, :he; μ = 2, p = 0.02, STPParam = SNN.MarkramSTPParameter())\nEI = SNN.SpikingSynapse(E, I, :ge; μ = 30, p = 0.02)\nIE = SNN.SpikingSynapse(I, E, :hi; μ = 50, p = 0.02, LTPParam = SNN.iSTDPRate(r=5Hz))\nII = SNN.SpikingSynapse(I, I, :gi; μ = 10, p = 0.02)\nmodel = SNN.compose(; E, I, EE, EI, IE, II)","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"To monitor any model variable, use the monitor! function. This function takes the component instance (e.g., E) and the symbol (or list of symbols) you want to record. Optionally, you can specify the sampling rate (sr, default: 1kHz) for the recording.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"","category":"page"},{"location":"recordings/#Population-Variables","page":"Recordings","title":"Population Variables","text":"","category":"section"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"First, let’s record variables associated with populations. We will record the excitatory and inhibitory conductances (:ge, :gi), firing rate (:fire), and membrane potential (:v) for all populations in the network model.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"SNN.monitor!(E, [:ge, :gi], sr=200Hz)\nSNN.monitor!(model.pop, :v, sr=200Hz)\nSNN.monitor!(model.pop, :fire)\nSNN.sim!(model = model; duration = 5second)","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"To access recorded variables, use the record function. This function takes the network component and the variable of interest as arguments. It returns an array (neurons × time), interpolated over the interval defined by :start_time and :end_time (the model’s time when monitor! was called and the last time point of the simulation). The resolution of the recording is determined by the sampling rate. Thanks to interpolation, you can access the variable at any continuous time point.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"v = SNN.record(model.pop.E, :v)\n@info \"V is: type $(nameof(typeof(v))), size $(size(v))\"\nv[1, 3.14s]\nv[1:10, 2.4s:15ms:3.1s]\nv, r = SNN.record(model.pop.E, :v, range=true)\n@info \"V is: type $(nameof(typeof(v))), size $(size(v)), r size: $(size(r))\"\nv = SNN.record(model.pop.E, :v, interpolate=false)\n@info \"V is: type $(nameof(typeof(v))), size $(size(v))\"","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"note: Note\nCurrently, it is not possible to deactivate recordings while keeping the variable in the monitored pool. This behavior may change in future updates.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"","category":"page"},{"location":"recordings/#Spiketimes-and-Firing-Rates","page":"Recordings","title":"Spiketimes and Firing Rates","text":"","category":"section"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"Spiketimes are stored as SNN.Spiketimes, a Vector of Vector. The first vector contains the spiketimes of each neuron in milliseconds (neurons × times).","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"# Spiketimes\nspiketimes = SNN.spiketimes(model.pop.E) # All spiketimes\n@info \"Spiketimes is: type $(nameof(typeof(spiketimes))), size $(size(spiketimes)), neuron 1 has $(length(spiketimes[1])) spikes\"\n\nspiketimes = SNN.spiketimes(model.pop.E; interval=0:1ms:5second) # Spiketimes in the specified interval\n@info \"Spiketimes is: type $(nameof(typeof(spiketimes))), size $(size(spiketimes)), neuron 1 has $(length(spiketimes[1])) spikes\"","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"For convenience, you can also access binned spikes using bin_spiketimes(comp<:AbstractPopulation; interval::AbstractRange). This function returns a tuple: a matrix (neurons × bins) where each entry represents the number of spikes in that bin, and the interval range. The spiketimes are binned within the extremes of interval, with the bin width defined by the interval step.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"# Binned spikes\ninterval = 0:10ms:5s # \nbins, r = SNN.bin_spiketimes(model.pop.E; interval)\n@info \"Bins is: type $(nameof(typeof(bins))), size $(size(bins)), r size: $(size(r))\"","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"To directly access the firing rate, use fr, r = SNN.firing_rate(model.pop.E; interval::AbstractRange). The firing rate is an interpolated array that samples a continuous firing rate signal at the time points defined by interval (a mandatory keyword argument). The continuous signal is obtained by convolving the binned spike train with an alpha-function kernel (time constant τ, default: 10ms). The firing rate is returned as a matrix (neurons × time points), where each entry represents the firing rate in Hz at that time point.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"# Firing rate\nfr, r = SNN.firing_rate(model.pop.E; interval) # Interpolated firing rate\n@info \"Fr is: type $(nameof(typeof(fr))), size $(size(fr)), r size: $(size(r))\"\nfr, r = SNN.firing_rate(model.pop.E; interval, interpolate=false) # Non-interpolated firing rate\n@info \"Fr is: type $(nameof(typeof(fr))), size $(size(fr)), r size: $(size(r))\"","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"You can also access the firing rate for the entire population:","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"fr, r, pop_names = SNN.firing_rate(model.pop; interval)","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"For simplicity, you can also access firing rates and spike times via the record function:","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"fr = SNN.record(model.pop.E, :fire; interval)\n@info \"Fr is: type $(nameof(typeof(fr))), size $(size(fr))\"\nfr, r = SNN.record(model.pop.E, :fire; interval, range=true)\n@info \"Fr is: type $(nameof(typeof(fr))), size $(size(fr)), r size: $(size(r))\"\nSNN.record(model.pop.E, :spikes)","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"note: Note\nThe model instance declared in the Main scope (E) and the instance in the network model (model.pop.E) point to the same object in memory. Operating on either is equivalent.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"note: Note\nRecorded variables are stored in the component’s records field. The storage method is non-trivial and subject to future changes, so we avoid detailing it here.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"","category":"page"},{"location":"recordings/#Synaptic-Variables","page":"Recordings","title":"Synaptic Variables","text":"","category":"section"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"We now add to the recordings the synaptic strength (:W) and efficacy (:ρ) for the inhibitory and excitatory connections. We also record the variables (:x and :u) for the STP in the excitatory connections and the filtered post-synaptic trace of the inhibitory STDP (:tpost). When recording plasticity variables, you must specify which set of variables you are referring to. This can be done using the keyword argument variables or implicitly by adding a third positional argument to the monitor! function.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"SNN.monitor!(EE, [:ρ], sr=10Hz)\nSNN.monitor!(EI, [:W], sr=10Hz)\nSNN.monitor!(IE, [:tpost]; sr=10Hz, variables=:LTPVars)\nSNN.monitor!(EE, [:x, :u], :STPVars; sr=10Hz)\nSNN.train!(model = model; duration = 5second)","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"warning: Warning\nRecording synaptic strength or efficacy can be memory-intensive in large networks. We recommend using a low sampling rate.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"note: Note\nSTPVars and LTPVars are special keywords representing sets of short-term and long-term plasticity-related variables, respectively.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"","category":"page"},{"location":"recordings/#Synaptic-Connectivity","page":"Recordings","title":"Synaptic Connectivity","text":"","category":"section"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"Synaptic connectivity is stored in a sparse format as a matrix with dimensions (N_post, N_pre). You can always access the synaptic weights of the connections directly:","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"W = SNN.matrix(EE)  # Default: returns the synaptic strength matrix at the last time point\nW = SNN.matrix(EE, :W)\nρ = SNN.record(EE, :ρ)","category":"page"},{"location":"recordings/#Accessing-Pre-and-Post-Synaptic-Neurons","page":"Recordings","title":"Accessing Pre- and Post-Synaptic Neurons","text":"","category":"section"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"You can access the pre- and post-synaptic neurons for a single neuron or a set of neurons:","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"Single Neuron","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"neuron = 1\nIs = SNN.postsynaptic(EE, neuron)  # Post-synaptic neurons\nmean(W[Is, neuron])  # Mean synaptic weight of post-synaptic connections\nJs = SNN.presynaptic(EE, neuron)  # Pre-synaptic neurons\nmean(W[neuron, Js])  # Mean synaptic weight of pre-synaptic connections","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"Multiple Neurons","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"neurons = 1:10\nW = SNN.matrix(EE)\nIs = SNN.presynaptic(EE, neurons)  # Pre-synaptic neurons for multiple neurons\nJs = SNN.postsynaptic(EE, neurons)  # Post-synaptic neurons for multiple neurons","category":"page"},{"location":"recordings/#Synaptic-Weight-Matrices","page":"Recordings","title":"Synaptic Weight Matrices","text":"","category":"section"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"When recorded, the matrix of synaptic weights or synaptic efficacy can be obtained using the record function. The returned value is a sparse matrix in a vector format, where only the non-zero values are maintained.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"Get the sparse vector ρ at time point t:","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"This returns only the non-zero elements of the matrix.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"ρ, r = SNN.record(EE, :ρ, range=true)\nhistogram(ρ[:, 6.5s])","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"Reconstruct the full matrix from the sparse vector ρ at time point t:","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"This operation reverses the sparse representation and returns the full matrix. You can pass either the vector obtained from SNN.record or the synapse object and the symbol of the variable.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"ρ_mat1 = SNN.matrix(EE, ρ, 6.5s)\nρ_mat2 = SNN.matrix(EE, :ρ, 6.5s)\nall(ρ_mat1 .== ρ_mat2)  # true","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"Get the matrix at multiple time points: This returns a 3D array of size (N_E, N_E, T), where T is the number of time points in the specified range.","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"ρ_T1 = SNN.matrix(EE, :ρ, 6.5s:10ms:7s)\nρ_T2 = SNN.matrix(EE, ρ, 6.5s:10ms:7s)","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"tip: Tip\nFor visualization, you can use the functions defined in SNNPlots library or use packages like Plots.jl to plot recorded variables or  using Plots\nplot(r, v[1,:], label=\"Membrane potential of neuron 1\")","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"","category":"page"},{"location":"recordings/#Plasticity-Variables","page":"Recordings","title":"Plasticity Variables","text":"","category":"section"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"Plasticity-related variables, such as STP (:x, :u) or LTP (:tpost), can also be accessed using the record function by adding the name of the set of variables of interest (STPVars or LTPVars) as a prefix. For example, to retrieve the STP variables for the synapse EE:","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"x = SNN.record(EE, :STPVars_x)\n@info \"x is: type $(nameof(typeof(x))), size $(size(x))\"\nx[1, 3.14s]\nx[1:10, 2.4s:15ms:3.1s]\nx, r = SNN.record(EE, :STPVars_x, range=true)\n@info \"x is: type $(nameof(typeof(x))), size $(size(x)), r size: $(size(r))\"\nx = SNN.record(EE, :STPVars_x, interpolate=false)\n@info \"x is: type $(nameof(typeof(x))), size $(size(x))\"","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"Similarly, for LTP variables in the synapse IE:","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"tpost = SNN.record(IE, :LTPVars_tpost)\n@info \"tpost is: type $(nameof(typeof(tpost))), size $(size(tpost))\"\ntpost[1, 3.14s]\ntpost[1:10, 2.4s:15ms:3.1s]\ntpost, r = SNN.record(IE, :LTPVars_tpost, range=true)\n@info \"tpost is: type $(nameof(typeof(tpost))), size $(size(tpost)), r size: $(size(r))\"\ntpost = SNN.record(IE, :LTPVars_tpost, interpolate=false)\n@info \"tpost is: type $(nameof(typeof(tpost))), size $(size(tpost))\"","category":"page"},{"location":"recordings/","page":"Recordings","title":"Recordings","text":"note: Note\nHigh sampling rates or recording many variables simultaneously can impact performance. Use subsampling (sr keyword) to balance memory usage and resolution.","category":"page"},{"location":"#SpikingNeuralNetworks.jl-Documentation","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Julia Spiking Neural Networks (JuliaSNN) is a library for simulating biophysical neuronal network models. ","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"This documentation is work in progress; please contact me via the GitHub repository if you have any specific questions or want to collaborate! ","category":"page"},{"location":"#Simple-and-powerful-simulation-framework","page":"SpikingNeuralNetworks.jl Documentation","title":"Simple and powerful simulation framework","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"The library's strength points are:","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Modular, intuitive, and quick instantiation of complex biophysical models;\nLarge pool of standard models already available and easy implementation of custom new models;\nHigh performance and native multi-threading support, laptop and cluster-friendly;\nAccess to all network's variables at runtime and save-load-rerun of arbitrarily complex networks;\nGrowing ecosystem for stimulation protocols, network analysis, and visualization (SNNUtils, SNNPlots, SNNGeometry).","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"SpikingNeuralNetworks.jl leverages the JuliaSNN ecosystem, which offers SNNPlots to plot models' recordings and SNNUtils for further stimulation protocols and analysis.","category":"page"},{"location":"#Models:-populations,-connections,-and-stimuli","page":"SpikingNeuralNetworks.jl Documentation","title":"Models: populations, connections, and stimuli","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"SpikingNeuralNetworks.jl builds on the idea that a neural network is composed of three classes of objects: the network populations, their recurrent connections, and the external stimuli they receive. Thus, a network model is simply a NamedTuple with keys: pop, syn, stim. The element associated with the keys must be concrete subtypes of AbstractPopulation, AbstractConnection, or AbstractStimulus. ","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Network models can be generated using compose with any population, connection, or stimulus type as keyworded arguments. The user can define the network model by associating the correct subtypes to the named tuple, but we advise against it. For example:","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"using SpikingNeuralNetworks\n\nE = SNN.IF(N = 100) # create an Integrate-and-Fire model population with 100 neurons. Use default parameters\n\nEE = SNN.SpikingSynapse(E, E, :ge, w = rand(E.N, E.N)) # connect the populations with recurrent, spiking synapses, targeting the :ge field.\nmy_model = SNN.compose(E=E, EE=EE) # create a model with the E population and the EE connection.\n# my_model = SNN.compose(;E, EE) # equivalent","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"compose assigns the correct types to the pop and syn and carries further integrity checks.  The population and synapse elements will be assigned to my_model.pop.E and my_model.syn.EE, respectively.","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"note: Note\nUser are not expected to use the abstract types, but only their concrete subtypes.\nNetwork models must at least include one population. Connections and Stimuli always target one population.\nBecause in biophysical network models connections are typically synapses, the two terms are used interchangeably. ","category":"page"},{"location":"#Pre-existing-models","page":"SpikingNeuralNetworks.jl Documentation","title":"Pre-existing models","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"For each subtype, JuliaSNN offers a library of pre-existing models. In the case above, an integrate-and-fire population (IF<:AbstractPopulation), a spiking synapse (SpikingSynapse<:AbstractSynapse). The collection of available models can be found under Models.","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Models can also be extended by importing the AbstractPopulation, AbstractConnection, or AbstractStimulus types. Guidelines on how to create new models are presented in Models Extensions  (WIP)","category":"page"},{"location":"#Simulation","page":"SpikingNeuralNetworks.jl Documentation","title":"Simulation","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Leveraging Julia's multiple dispatch, the simulation loop calls the methods defined for each type of model and parameter:","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"\nfunction sim!(...)\n    update_time!(T, dt)\n    for s in stimuli\n        s_type = getfield(s, :param)\n        stimulate!(s, s_type, T, dt)\n        record!(s, T)\n    end\n    for p in populations\n        p_type = getfield(t, :param)\n        integrate!(p, p_type, dt)\n        record!(p, T)\n    end\n    for c in connections\n        c_type = getfield(c, :param)\n        forward!(c, c_type)\n        ## if train!(...) \n            plasticity!(c, c.param, dt, T)\n        record!(c, T)\n    end\nend","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"In a loop step, the first to be activated are the stimuli which provide inputs to the populations. Thus, the differential equations associated to the populations are integrated. Finally, the population activity is propagated through the synapses (connections!). ","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Using Julia's passing-by-sharing, connections and stimuli maintain internal pointers to the populations' fields they are attached to. This allow to seamlessy read and updates the populations variables within the stimulate! and forward! functions.","category":"page"},{"location":"#Installation","page":"SpikingNeuralNetworks.jl Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"JuliaSNN/SpikingNeuralNetworks.jl is available on the public Julia repository. Install the module via ]add SpikingNeuralNetworks.","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"You can install the latest version directly from the git repository:","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"]add https://github.com/JuliaSNN/SpikingNeuralNetworks.jl","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"To learn how to use the library you can follow the Tutorial.","category":"page"}]
}
