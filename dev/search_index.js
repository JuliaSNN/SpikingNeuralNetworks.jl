var documenterSearchIndex = {"docs":
[{"location":"api_reference/#API-References","page":"API References","title":"API References","text":"","category":"section"},{"location":"api_reference/","page":"API References","title":"API References","text":"Pages = [\"api_reference.md\"]","category":"page"},{"location":"api_reference/#Populations","page":"API References","title":"Populations","text":"","category":"section"},{"location":"api_reference/#SNNModels.AbstractPopulation","page":"API References","title":"SNNModels.AbstractPopulation","text":"AbstractPopulation\n\nAn abstract type representing a population. Any struct inheriting from this type must implement:\n\nMethods\n\nintegrate!(p::NeuronModel, param::NeuronModelParam, dt::Float32): Integrates the neuron model over a time step dt using the given parameters.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.BallAndStick","page":"API References","title":"SNNModels.BallAndStick","text":"This is a struct representing a spiking neural network model that include two dendrites and a soma based on the adaptive exponential integrate-and-fire model (AdEx)\n\nFields\n\nt::VIT : tracker of simulation index [0] \nparam::AdExSoma : Parameters for the AdEx model.\nN::Int32 : The number of neurons in the network.\nd::VDT: Dendritic compartment parameters.\nv_s::VFT : Somatic membrane potential.\nw_s::VFT : Adaptation variables for each soma.\nv_d::VFT: Dendritic membrane potential for dendrite.\ng_s::MFT , g_d::MFT : Conductance of somatic and dendritic synapses.\nh_s::MFT, h_d::MFT  : Synaptic gating variables.\nfire::VBT : Boolean array indicating which neurons have fired.\nafter_spike::VFT : Post-spike timing.\npostspike::PST : Model for post-spike behavior.\nθ::VFT : Individual neuron firing thresholds.\nrecords::Dict : A dictionary to store simulation results.\nΔv::VFT , Δv_temp::VFT : Variables to hold temporary voltage changes.\ncs::VFT , is::VFT : Temporary variables for currents.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.HH","page":"API References","title":"SNNModels.HH","text":"Hodgkin–Huxley Neuron\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.IF","page":"API References","title":"SNNModels.IF","text":"[Integrate-And-Fire Neuron](https://neuronaldynamics.epfl.ch/online/Ch1.S3.html)\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.IF_CANAHP","page":"API References","title":"SNNModels.IF_CANAHP","text":"[CAN-AHP Intergrate-and-Fire Neuron](https://www.biorxiv.org/content/10.1101/2022.07.26.501548v1)\n\nIF neuron with non-specific cationic (CAN) and after-hyperpolarization potassium (AHP) currents.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.IZ","page":"API References","title":"SNNModels.IZ","text":"Izhikevich Neuron\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.MorrisLecar","page":"API References","title":"SNNModels.MorrisLecar","text":"Morris-Lecar Neuron\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Poisson","page":"API References","title":"SNNModels.Poisson","text":"Poisson Neuron\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Rate","page":"API References","title":"SNNModels.Rate","text":"Rate Neuron\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Tripod","page":"API References","title":"SNNModels.Tripod","text":"This is a struct representing a spiking neural network model that include two dendrites and a soma based on the adaptive exponential integrate-and-fire model (DendNeuronParameter)\n\nFields\n\nt::VIT : tracker of simulation index [0] \nparam::AdExSoma : Parameters for the AdEx model.\nN::Int32 : The number of neurons in the network.\nsoma_syn::ST : Synapses connected to the soma.\ndend_syn::ST : Synapses connected to the dendrites.\nd1::VDT, d2::VDT : Dendrite structures.\nNMDA::NMDAT : Specifies the properties of NMDA (N-methyl-D-aspartate) receptors.\ngax1::VFT, gax2::VFT : Axial conductance (reciprocal of axial resistance) for dendrite 1 and 2 respectively.\ncd1::VFT, cd2::VFT : Capacitance for dendrite 1 and 2.\ngm1::VFT, gm2::VFT : Membrane conductance for dendrite 1 and 2.\nv_s::VFT : Somatic membrane potential.\nw_s::VFT : Adaptation variables for each soma.\nv_d1::VFT , v_d2::VFT : Dendritic membrane potential for dendrite 1 and 2.\ng_s::MFT , g_d1::MFT, g_d2::MFT : Conductance of somatic and dendritic synapses.\nh_s::MFT, h_d1::MFT, h_d2::MFT : Synaptic gating variables.\nfire::VBT : Boolean array indicating which neurons have fired.\nafter_spike::VFT : Post-spike timing.\npostspike::PST : Model for post-spike behavior.\nθ::VFT : Individual neuron firing thresholds.\nrecords::Dict : A dictionary to store simulation results.\nΔv::VFT , Δv_temp::VFT : Variables to hold temporary voltage changes.\ncs::VFT , is::VFT : Temporary variables for currents.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Synapses","page":"API References","title":"Synapses","text":"","category":"section"},{"location":"api_reference/#SNNModels.AbstractConnection","page":"API References","title":"SNNModels.AbstractConnection","text":"AbstractConnection\n\nAn abstract type representing a connection. Any struct inheriting from this type must implement:\n\nMethods\n\nforward!(c::Synapse, param::SynapseParameter): Propagates the signal through the synapse.\nplasticity!(c::Synapse, param::SynapseParameter, dt::Float32, T::Time): Updates the synapse parameters based on plasticity rules.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.AbstractNormalization","page":"API References","title":"SNNModels.AbstractNormalization","text":"AbstractNormalization <: AbstractConnection\n\nAn abstract type representing a normalization connection.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.AbstractSparseSynapse","page":"API References","title":"SNNModels.AbstractSparseSynapse","text":"AbstractSparseSynapse <: AbstractConnection\n\nAn abstract type representing a sparse synapse connection.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.AggregateScaling-Tuple{Any, Any}","page":"API References","title":"SNNModels.AggregateScaling","text":"SynapseNormalization(N; param, kwargs...)\n\nConstructor function for the SynapseNormalization struct.\n\nN: The number of synapses.\nparam: Normalization parameter, can be either MultiplicativeNorm or AdditiveNorm.\nkwargs: Other optional parameters.\n\nReturns a SynapseNormalization object with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.FLSparseSynapse","page":"API References","title":"SNNModels.FLSparseSynapse","text":"Force Learning Sparse Synapse\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.FLSynapse","page":"API References","title":"SNNModels.FLSynapse","text":"Force Learning Full Synapse\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PINningSparseSynapse","page":"API References","title":"SNNModels.PINningSparseSynapse","text":"PINing Sparse Synapse\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PINningSynapse","page":"API References","title":"SNNModels.PINningSynapse","text":"PINing Sparse Synapse\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.RateSynapse","page":"API References","title":"SNNModels.RateSynapse","text":"Rate Synapse\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.SpikeRateSynapse","page":"API References","title":"SNNModels.SpikeRateSynapse","text":"Rate Synapse\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.SpikingSynapse","page":"API References","title":"SNNModels.SpikingSynapse","text":"SpikingSynapse to connect neuronal populations\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.SynapseNormalization","page":"API References","title":"SNNModels.SynapseNormalization","text":"SynapseNormalization{VFT = Vector{Float32}, VIT = Vector{Int32}, MFT = Matrix{Float32}}\n\nA struct that holds parameters for synapse normalization, including:\n\nparam: Normalization parameter, can be either MultiplicativeNorm or AdditiveNorm.\nt: A vector of integer values representing time points.\nW0: A vector of initial weights before simulation.\nW1: A vector of weights during the simulation.\nμ: A vector of mean synaptic weights.\nrecords: A dictionary for storing additional data.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.SynapseNormalization-Tuple{Any, Any}","page":"API References","title":"SNNModels.SynapseNormalization","text":"SynapseNormalization(N; param, kwargs...)\n\nConstructor function for the SynapseNormalization struct.\n\nN: The number of synapses.\nparam: Normalization parameter, can be either MultiplicativeNorm or AdditiveNorm.\nkwargs: Other optional parameters.\n\nReturns a SynapseNormalization object with the specified parameters.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Stimuli","page":"API References","title":"Stimuli","text":"","category":"section"},{"location":"api_reference/#SNNModels.AbstractStimulus","page":"API References","title":"SNNModels.AbstractStimulus","text":"AbstractStimulus\n\nAn abstract type representing a stimulus. Any struct inheriting from this type must implement:\n\nMethods\n\nstimulate!(p::Stimulus, param::StimulusParameter, time::Time, dt::Float32): Applies the stimulus to the population.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.BalancedStimulus-Union{Tuple{R}, Tuple{T}, Tuple{T, Symbol, Symbol}, Tuple{T, Symbol, Symbol, Any}} where {T<:SNNModels.AbstractPopulation, R<:Real}","page":"API References","title":"SNNModels.BalancedStimulus","text":"BalancedStimulus(post::T, sym::Symbol, r::Union{Function, Float32}, neurons=[]; N_pre::Int=50, p_post::R=0.05f0, μ::R=1.f0, param=BalancedParameter()) where {T <: AbstractPopulation, R <: Number}\n\nConstructs a BalancedStimulus object for a spiking neural network.\n\nArguments\n\npost::T: The target population for the stimulus.\nsym::Symbol: The symbol representing the synaptic conductance or current.\nr::Union{Function, Float32}: The firing rate of the stimulus. Can be a constant value or a function of time.\nneurons=[]: The indices of the neuronsin the target population that receive the stimulus. If empty, neuronsare randomly selected based on the probability p_post.\nN::Int=200: The number of Balanced neurons neurons.\nN_pre::Int=5: The number of presynaptic connected.\np_post::R=0.05f0: The probability of connection between presynaptic and postsynaptic neurons.\nμ::R=1.f0: The scaling factor for the synaptic weights.\nparam=BalancedParameter(): The parameters for the Balanced distribution.\n\nReturns\n\nA BalancedStimulus object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Plasticity","page":"API References","title":"Plasticity","text":"","category":"section"},{"location":"api_reference/#SNNModels.STDPGerstner","page":"API References","title":"SNNModels.STDPGerstner","text":"Gerstner, W., Kempter, R., van Hemmen, J. L., & Wagner, H. (1996). A neuronal learning rule for sub-millisecond temporal coding. Nature, 383(6595), 76–78. https://doi.org/10.1038/383076a0\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.STDPMexicanHat","page":"API References","title":"SNNModels.STDPMexicanHat","text":"STDPMexicanHat{FT = Float32}\n\nThe STDP is defined such that integral of the kernel is zero. The STDP kernel is defined as:\n\n`` A x * exp(-x/sqrt(2)) ``\n\nwhere   ``A`` is the learning rate for post and pre-synaptic spikes, respectively, and ``x`` is the difference between the post and pre-synaptic traces.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.STDPSymmetric","page":"API References","title":"SNNModels.STDPSymmetric","text":"STDPSymmetric{FT = Float32}\n\nSymmetric STDP rules described in:\n`Structured stabilization in recurrent neural circuits through inhibitory synaptic plasticity` \nby Festa, D., Cusseddu, C, and Gjorgjieva, J. (2024).\n\nThe STDP is defined such that integral of the kernel is zero. The STDP kernel is defined as:\n\n`` (\frac{A_{post}}{1/\tau_{post}} * exp(-t/\tau_{post} - \frac{A_{pre}}{\tau_pre} * exp(-t/\tau_{pre}) ``\n\nwhere ``A_{post}`` and ``A_{pre}`` are the learning rates for post and pre-synaptic spikes, respectively, and ``\tau_{post}`` and ``\tau_{pre}`` are the time constants for post and pre-synaptic traces, respectively.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.vSTDPParameter","page":"API References","title":"SNNModels.vSTDPParameter","text":"vSTDPParameter{FT = Float32} <: SpikingSynapseParameter\n\nContains parameters for the voltage-dependent Spike-Timing Dependent Plasticity (vSTDP) model.\n\nFields\n\nA_LTD::FT: Long Term Depression learning rate.\nA_LTP::FT: Long Term Potentiation learning rate.\nθ_LTD::FT: LTD threshold.\nθ_LTP::FT: LTP threshold.\nτu::FT: Time constant for the pre-synaptic spike trace.\nτv::FT: Time constant for the post-synaptic membrane trace.\nτx::FT: Time constant for the variable x.\nWmax::FT: Maximum synaptic weight.\nWmin::FT: Minimum synaptic weight.\nactive::Vector{Bool}: Flag to activate or deactivate the plasticity rule.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Functions","page":"API References","title":"Functions","text":"","category":"section"},{"location":"api_reference/#SNNModels.CV_isi2-Tuple{Vector{Float32}}","page":"API References","title":"SNNModels.CV_isi2","text":"CV_isi2(intervals::Vector{Float32})\n\nReturn the local coefficient of variation of the interspike intervals\nHolt, G. R., Softky, W. R., Koch, C., & Douglas, R. J. (1996). Comparison of discharge variability in vitro and in vivo in cat visual cortex neurons. Journal of Neurophysiology, 75(5), 1806–1814. https://doi.org/10.1152/jn.1996.75.5.1806\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.C_mem-Tuple{}","page":"API References","title":"SNNModels.C_mem","text":"C_mem(;Cd=Cd,d=d,l=l)\nCapacitance of a cylinder of length l and diameter d\nreturn Capacitance in pF\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.G_axial-Tuple{}","page":"API References","title":"SNNModels.G_axial","text":"G_axial(;Ri=Ri,d=d,l=l)\nAxial conductance of a cylinder of length l and diameter d\nreturn Conductance in nS\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.G_mem-Tuple{}","page":"API References","title":"SNNModels.G_mem","text":"G_mem(;Rd=Rd,d=d,l=l)\nMembrane conductance of a cylinder of length l and diameter d\nreturn Conductance in nS\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.alpha_function-Tuple{Float32, Float32}","page":"API References","title":"SNNModels.alpha_function","text":"alpha_function(t::T; t0::T, τ::T) where T <: AbstractFloat\n\nAlpha function for convolution of spiketimes. Evaluate the alpha function at time t, with time of peak t0 and time constant τ.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.asynchronous_state","page":"API References","title":"SNNModels.asynchronous_state","text":"inter_spike_interval(spiketimes::Vector{Float32})\n\nCalculate the inter-spike intervals (ISIs) for a given set of spike times.\n\nArguments\n\nspiketimes: A vector of spike times for a single neuron.\n\nReturns\n\nisis: A vector of inter-spike intervals.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.bin_spiketimes-Tuple{Vector{Float32}}","page":"API References","title":"SNNModels.bin_spiketimes","text":"bin_spiketimes(spiketimes, interval, sr)\n\nGiven a list of spike times spiketimes, an interval [start, end], and a sampling rate sr, this function counts the number of spikes that fall within each time bin of width 1/sr within the interval. The function returns a sparse matrix count containing the spike counts for each bin, and an array r containing the time points corresponding to the center of each bin.\n\nArguments\n\nspiketimes: A 1-dimensional array of spike times.\ninterval: A 2-element array specifying the start and end times of the interval.\nsr: The sampling rate, i.e., the number of time bins per second.\n\nReturns\n\ncount: A sparse matrix containing the spike counts for each time bin.\nr: An array of time points corresponding to the center of each time bin.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.clear_monitor!-Tuple{Any}","page":"API References","title":"SNNModels.clear_monitor!","text":"clear_monitor!(obj)\n\nClears all the records of a given object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.clear_records!-Tuple{AbstractArray}","page":"API References","title":"SNNModels.clear_records!","text":"clear_records!(objs::AbstractArray)\n\nClears the records of multiple objects.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.clear_records!-Tuple{Any, Symbol}","page":"API References","title":"SNNModels.clear_records!","text":"clear_records!(obj, sym::Symbol)\n\nClears the records of a given object for a specific symbol.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.clear_records!-Tuple{Any}","page":"API References","title":"SNNModels.clear_records!","text":"clear_records!(obj)\n\nClears all the records of a given object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.compose-Tuple","page":"API References","title":"SNNModels.compose","text":"compose(kwargs...; syn=nothing, pop=nothing)\n\nMerge multiple models into a single model.\n\nArguments\n\nkwargs...: List of kwarg elements, i.e., dictionary or named tuples, containing the models to be merged.\nif kwarg has elements with :pop and :syn entries, the function copies them into the merged model.\nif kwarg has no :pop and :syn entries, the function iterates over all the elements contained in kwarg and merge them into the model.\nsyn: Optional dictionary of synapses to be merged.\npop: Optional dictionary of populations to be merged.\nstim: Optional dictionary of stimuli to be merged.\n\nReturns\n\nA tuple (pop, syn) representing the merged populations and synapses.\n\nDetails\n\nThis function takes in multiple models represented as keyword arguments and merges them into a single model. The models can be specified using the pop and syn fields in the keyword arguments. If the pop and syn fields are not present, the function expects the keyword arguments to have elements with :pop or :syn fields.\n\nThe merged populations and synapses are stored in dictionaries populations and synapses, respectively. The function performs type assertions to ensure that the elements being merged are of the correct types (AbstractPopulation for populations and AbstractConnection for synapses).\n\nIf syn and/or pop and/or stim arguments are provided, they are merged into the respective dictionaries.\n\nExample\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.compute_connections-Tuple{Symbol, Symbol, Any}","page":"API References","title":"SNNModels.compute_connections","text":"compute_long_short_connections(pre::Symbol, post::Symbol, points; dc, pl, ϵ, grid_size, conn)\n\nCompute the connections between two populations of neurons based on their spatial distance. This function will assign connections with probability p_short for short-range connections and p_long for long-range connections. The weights of the connections are determined by the μ parameter in the conn named tuple.  The function uses a periodic boundary condition to calculate distances in a 2D grid. The total number of connections per the post-synaptic neuron is: ϵ * Npre * pshort + (1 - ϵ) * Npre * plong.\n\nArguments\n\npre::Symbol: The symbol representing the pre-synaptic population.\npost::Symbol: The symbol representing the post-synaptic population.\npoints::NamedTuple: A named tuple containing the spatial points for each population.\ndc::Float64: The critical distance for short-range connections.\npl::Float64: The probability of long-range connections.\nϵ::Float64: The scaling factor for connection probabilities.\ngrid_size::Float64: The size of the grid.\nconn::NamedTuple: A named tuple containing connection parameters, including p and μ.\n\nReturns\n\nP::Matrix{Bool}: A matrix indicating the presence of connections.\nW::Matrix{Float32}: A matrix containing the weights of the connections.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.compute_covariance_density-Tuple{Vector{Float32}, Vector{Float32}}","page":"API References","title":"SNNModels.compute_covariance_density","text":"compute_covariance_density(t_post, t_pre, T; τ=200ms, sr=50Hz)\n\nCompute the covariance density of spike trains t_post and t_pre over a time interval T. The function returns the covariance density vectors for positive and negative time lags.\n\nArguments\n\nspike_times1:: Vector{Float32}: A vector of spike times for the first neuron.\nspike_times2:: Vector{Float32}: A vector of spike times for the second neuron.\nbin_width:: Float32: The width of the time bins in milliseconds.\nmax_lag:: Float32: The maximum time lag in milliseconds.\n\nReturns\n\nlags:: Vector{Float32}: The time lags in milliseconds.\ncovariance_density:: Vector{Float32}: The covariance density for each time lag.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.compute_cross_correlogram","page":"API References","title":"SNNModels.compute_cross_correlogram","text":"autocor(spiketimes::Spiketimes; interval = 0:1:1000)\n\nCalculate the cross-correlation of two spike trains.\n\nArguments\n\nspike_times1: A vector of spike times for the first neuron.\nspike_times2: A vector of spike times for the second neuron.\nbin_width: The width of the time bins in milliseconds.\nmax_lag: The maximum time lag in milliseconds.\n\nReturns\n\nlags: The time lags in milliseconds.\nauto_corr: The auto-correlation for each time lag.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.extract_items-Tuple{Symbol, Any}","page":"API References","title":"SNNModels.extract_items","text":"extract_items(root::Symbol, container; pop::Dict{Symbol,Any}, syn::Dict{Symbol, Any}, stim::Dict{Symbol,Any})\n\nExtracts items from a container and adds them to the corresponding dictionaries based on their type.\n\nArguments\n\nroot::Symbol: The root symbol for the items being extracted.\ncontainer: The container from which to extract items.\npop::Dict{Symbol,Any}: The dictionary to store population items.\nsyn::Dict{Symbol, Any}: The dictionary to store synapse items.\nstim::Dict{Symbol,Any}: The dictionary to store stimulus items.\n\nReturns\n\ntrue: Always returns true.\n\nDetails\n\nIf the type of the item in the container is AbstractPopulation, it is added to the pop dictionary.\nIf the type of the item in the container is AbstractConnection, it is added to the syn dictionary.\nIf the type of the item in the container is AbstractStimulus, it is added to the stim dictionary.\nIf the type of the item in the container is none of the above, the function is recursively called to extract items from the nested container.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.firing_rate-Tuple{Vector{Vector{Float32}}}","page":"API References","title":"SNNModels.firing_rate","text":"firing_rate(\n    spiketimes::Spiketimes,\n    interval::AbstractVector = [],\n    sampling = 20,\n    τ = 25,\n    ttf = -1,\n    tt0 = -1,\n    cache = true,\n    pop::Union{Symbol,Vector{Int}}= :ALL,\n)\n\nCalculate the firing rates for a population or an individual neuron.\n\nArguments\n\nspiketimes: Spiketimes object.\ninterval: Time interval vector (default is an empty vector).\nsampling: Sampling rate (default is 20ms).\nτ: Time constant for convolution (default is 25ms).\nttf: Final time point (default is -1, which means until the end of the simulation time).\ntt0: Initial time point (default is -1, which means from the start of the simulation time based on the sampling rate).\ncache: If true, uses cached data (default is true).\npop: Either :ALL for all populations or a Vector of Integers specifying specific neuron indices. Default is :ALL.\n\nReturns\n\nA tuple containing:\n\nrates: A vector of firing rates for each neuron in the chosen population.\ninterval: The time interval over which the firing rates were calculated.\n\nExamples\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.firing_rate_average-Tuple{Any}","page":"API References","title":"SNNModels.firing_rate_average","text":"firing_rate_average(P; dt=0.1ms)\n\nCalculates and returns the average firing rates of neurons in a network.\n\nArguments:\n\nP: A structure containing neural data, with a key :fire in its records field which stores spike information for each neuron.\ndt: An optional parameter specifying the time interval (default is 0.1ms).\n\nReturns:\n\nAn array of floating point values representing the average firing rate for each neuron.\n\nUsage:# Notes:\n\nEach row of P.records[:fire] represents a neuron, and each column represents a time point. The value in a cell indicates whether that neuron has fired at that time point (non-zero value means it has fired). The firing rate of a neuron is calculated as the total number of spikes divided by the total time span.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.gaussian_kernel-Tuple{Real, Int64}","page":"API References","title":"SNNModels.gaussian_kernel","text":"gaussian_kernel(σ::Float64, length::Int)\n\nCreate a Gaussian kernel with standard deviation σ and specified length.\n\nArguments\n\nσ: Standard deviation of the Gaussian kernel.\nlength: Length of the kernel.\n\nReturns\n\nkernel: A vector representing the Gaussian kernel.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.gaussian_kernel_estimate-Tuple{Vector, Real}","page":"API References","title":"SNNModels.gaussian_kernel_estimate","text":"gaussian_kernel_estimate(support_vector::Vector{Float64}, σ::Float64, length::Int)\n\nApply a Gaussian kernel estimate to a support vector with closed boundary conditions.\n\nArguments\n\nsupport_vector: The input support vector.\nσ: Standard deviation of the Gaussian kernel.\nlength: Length of the kernel.\n\nReturns\n\nestimated_vector: The estimated vector after applying the Gaussian kernel.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.get_dt-Tuple{SNNModels.Time}","page":"API References","title":"SNNModels.get_dt","text":"get_dt(T::Time)\n\nGet the time step size.\n\nArguments\n\nT::Time: The Time object.\n\nReturns\n\nFloat32: The time step size.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.get_interval-Tuple{SNNModels.Time}","page":"API References","title":"SNNModels.get_interval","text":"get_interval(T::Time)\n\nGet the time interval from 0 to the current time.\n\nArguments\n\nT::Time: The Time object.\n\nReturns\n\nStepRange{Float32}: The time interval.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.get_step-Tuple{SNNModels.Time}","page":"API References","title":"SNNModels.get_step","text":"get_step(T::Time)\n\nGet the current time step.\n\nArguments\n\nT::Time: The Time object.\n\nReturns\n\nFloat32: The current time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.get_time-Tuple{SNNModels.Time}","page":"API References","title":"SNNModels.get_time","text":"get_time(T::Time)\n\nGet the current time.\n\nArguments\n\nT::Time: The Time object.\n\nReturns\n\nFloat32: The current time.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.getrecord-Tuple{Any, Any}","page":"API References","title":"SNNModels.getrecord","text":"getrecord(p, sym)\n\nReturns the recorded values for a given object and symbol. If the symbol is not found in the object's records, it checks the records of the object's plasticity and returns the values for the matching symbol.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.getvariable","page":"API References","title":"SNNModels.getvariable","text":"getvariable(obj, key, id=nothing)\n\nReturns the recorded values for a given object and key. If an id is provided, returns the recorded values for that specific id.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.graph-Tuple{Any}","page":"API References","title":"SNNModels.graph","text":"graph(model)\n\nGenerate a graph representation of the model.\n\nArguments\n\nmodel: The model to generate the graph from.\n\nReturns\n\nA MetaGraphs.MetaDiGraph object representing the graph.\n\nDetails\n\nEach vertex represents either a population ('pop'), a normalization synapse ('norm'), or a stimulus pre-target ('pre').  Its metadata includes:\nname: Actual name of the population, 'norm' for a SynapseNormalization, or the pre-target's name for a stimulus.\nid: Identifier of the population, SynapseNormalization, or stimulus.\nkey: Key from the original 'pop', 'syn', or 'stim' dictionary in the model.\nEach edge represents a synaptic connection or a stimulus.  Its metadata includes:\ntype: Type of the edge, ':firetog' for SpikingSynapse, ':norm' for SynapseNormalization, or ':stim' for a stimulus.\nname: Name of the edge, formatted as \"fromvertexname to tovertexname\".\nkey: Key from the original 'syn' or 'stim' dictionary in the model.\nid: Identifier of the synapse or stimulus.    \nThe function iterates over the populations, synapses, and stimuli in the model.\n\nAbstractPopulation items are added as vertices.\n\nFor each connection it checks the type of the synapse and adds an edge between the pre-synaptic population and the post-synaptic population.      - SpikingSynapse: the edge represents a connection from the firing population to the receiving population.        - SynapseNormalization: the edge represents a normalization of synapses between populations.     - PoissonStimulus: the edge represents a stimulus from the pre-synaptic population to the post-synaptic population.\n\nFor each stimulus, it adds a vertex to the graph representing an implicit pre-synaptic population [:fire] an edge between it and the post-synaptic population [:post].\n\nReturns a MetaGraphs.MetaDiGraph where:\n\nErrors\n\nThrows ArgumentError when the synapse type is neither SpikingSynapse nor SynapseNormalization.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.interpolated_record-Tuple{Any, Any}","page":"API References","title":"SNNModels.interpolated_record","text":"interpolated_record(p, sym)\n\nReturns the recording with interpolated time values and the extrema of the recorded time points.\n\nN.B. \n----\nThe element can be accessed at whichever time point by using the index of the array. The time point must be within the range of the recorded time points, in r_v.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.interval_standard_spikes-Tuple{Any, Any}","page":"API References","title":"SNNModels.interval_standard_spikes","text":"interval_standard_spikes(spiketimes, interval)\n\nStandardize the spiketimes to the interval [0, interval_duration]. Return a copy of the 'Spiketimes' vector. \n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.is_attractor_state-Union{Tuple{T}, Tuple{T, AbstractVector}} where T<:SNNModels.AbstractPopulation","page":"API References","title":"SNNModels.is_attractor_state","text":"is_attractor_state(spiketimes::Spiketimes, interval::AbstractVector, N::Int)\n\nCheck if the network is in an attractor state by verifying that the average firing rate over the last N seconds of the simulation is a unimodal distribution.\n\nArguments\n\nspiketimes: A vector of vectors containing the spike times of each neuron.\ninterval: The time interval over which to compute the firing rate.\nN: The number of seconds over which to check the unimodality of the firing rate distribution.\n\nReturns\n\nis_attractor: A boolean indicating whether the network is in an attractor state.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.linear_network-Tuple{Any}","page":"API References","title":"SNNModels.linear_network","text":"linear_network(N, σ_w=0.38, w_max=2.0)\n\nCreate a linear network with Gaussian-shaped connections.\n\nArguments\n\nN::Int: The number of neurons.\nσ_w::Float64: The standard deviation of the Gaussian distribution.\nw_max::Float64: The maximum weight.\n\nReturns\n\nW::Matrix{Float32}: A matrix containing the weights of the connections.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.merge_spiketimes-Tuple{Vector{Vector{Vector{Float32}}}}","page":"API References","title":"SNNModels.merge_spiketimes","text":"merge_spiketimes(spikes::Vector{Spiketimes}; )\n\nMerge spiketimes from different simulations. \nThis function is not thread safe, it is not recommended to use it in parallel.\nParameters\n----------\nspikes: Vector{Spiketimes}\n    Vector of spiketimes from different simulations\nReturn\n------\nneurons: Spiketimes\n    Single vector of spiketimes\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.monitor!-Tuple{Array, Any}","page":"API References","title":"SNNModels.monitor!","text":"monitor!(objs::Array, keys)\n\nFunction called when more than one object is given, which then calls the above monitor function for each object\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.monitor!-Union{Tuple{Item}, Tuple{Item, Any}} where Item<:Union{SNNModels.AbstractConnection, SNNModels.AbstractPopulation, SNNModels.AbstractStimulus}","page":"API References","title":"SNNModels.monitor!","text":"Initialize dictionary records for the given object, by assigning empty vectors to the given keys\n\nArguments\n\nobj: An object whose variables will be monitored\nkeys: The variables to be monitored\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.neurons_outside_area-NTuple{4, Any}","page":"API References","title":"SNNModels.neurons_outside_area","text":"neurons_outside_area(points, center, distance, grid_size)\n\nFind the indices of neurons outside a specified area around a center point.\n\nArguments\n\npoints::Vector{Vector{Float64}}: The coordinates of the neurons.\ncenter::Vector{Float64}: The coordinates of the center point.\ndistance::Float64: The minimum distance from the center point.\ngrid_size::Float64: The size of the grid.\n\nReturns\n\nindices::Vector{Int}: The indices of neurons outside the specified area.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.neurons_within_circle-NTuple{4, Any}","page":"API References","title":"SNNModels.neurons_within_circle","text":"neurons_within_circle(points, center, distance, grid_size)\n\nFind the indices of neurons within a specified area around a center point.\n\nArguments\n\npoints::Vector{Vector{Float64}}: The coordinates of the neurons.\ncenter::Vector{Float64}: The coordinates of the center point.\ndistance::Float64: The maximum distance from the center point.\ngrid_size::Float64: The size of the grid.\n\nReturns\n\nindices::Vector{Int}: The indices of neurons within the specified area.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.norm_synapse-Tuple{Any, Any}","page":"API References","title":"SNNModels.norm_synapse","text":"Calculate the normalization factor for a synapse given rise and decay time constants.\n\nArguments\n\nτr: Rise time constant\nτd: Decay time constant\n\nReturns\n\nFloat32: The normalization factor\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.norm_synapse-Tuple{SNNModels.Receptor}","page":"API References","title":"SNNModels.norm_synapse","text":"Calculate the normalization factor for a synapse.\n\nArguments\n\nsynapse::Receptor: The receptor for which to calculate the normalization factor\n\nReturns\n\nFloat32: The normalization factor\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.periodic_distance-Tuple{Any, Any, Any}","page":"API References","title":"SNNModels.periodic_distance","text":"periodic_distance(point1, point2, grid_size)\n\nCalculate the periodic distance between two points in a 2D grid.\n\nArguments\n\npoint1::Vector{Float64}: The coordinates of the first point.\npoint2::Vector{Float64}: The coordinates of the second point.\ngrid_size::Float64: The size of the grid.\n\nReturns\n\ndistance::Float64: The periodic distance between the two points.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.place_populations-Tuple{Any, Any}","page":"API References","title":"SNNModels.place_populations","text":"place_populations(config)\n\nCreate a 2D spatial structure and dispose N points for each population.\n\nArguments\n\nconfig::NamedTuple: A NamedTuple containing configuration parameters, including projections and Npop.\n\nReturns\n\nPops::NamedTuple: A named tuple containing the spatial points for each population.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.plasticity!-Tuple{SNNModels.AbstractSparseSynapse, SNNModels.iSTDPPotential, SNNModels.iSTDPVariables, Float32, SNNModels.Time}","page":"API References","title":"SNNModels.plasticity!","text":"plasticity!(c::AbstractSparseSynapse, param::iSTDPRate, dt::Float32)\n\nPerforms the synaptic plasticity calculation based on the inihibitory spike-timing dependent plasticity (iSTDP) model from Vogels (2011) adapted to control the membrane potential.  The function updates synaptic weights W of each synapse in the network according to the firing status of pre and post-synaptic neurons. This is an in-place operation that modifies the input AbstractSparseSynapse object c.\n\nArguments\n\nc::AbstractSparseSynapse: The current spiking synapse object which contains data structures to represent the synapse network.\nparam::iSTDPParameterVoltage: Parameters needed for the iSTDP model, including learning rate η, target membrane potenital v0, STDP time constant τy, maximal and minimal synaptic weight (Wmax and Wmin).\ndt::Float32: The time step for the numerical integration.\n\nAlgorithm\n\nFor each pre-synaptic neuron, if it fires, it reduces the synaptic weight by an amount proportional to the difference between the target membrane potential and the actual one. \nFor each pre-synaptic neuron, if it fires, increases the inhibitory term, otherwise the inhibitory term decays exponentially over time with a time constant τy.\nFor each post-synaptic neuron, if it fires, it increases the synaptic weight by an amount proportional to the pre-synaptic trace and increases the excitatory term, otherwise the excitatory term decays exponentially over time with a time constant τy.\nThe synaptic weights are bounded by Wmin and Wmax.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.plasticity!-Tuple{SNNModels.AbstractSparseSynapse, SNNModels.iSTDPRate, SNNModels.iSTDPVariables, Float32, SNNModels.Time}","page":"API References","title":"SNNModels.plasticity!","text":"plasticity!(c::AbstractSparseSynapse, param::iSTDPRate, dt::Float32)\n\nPerforms the synaptic plasticity calculation based on the inihibitory spike-timing dependent plasticity (iSTDP) model from Vogels (2011).  The function updates synaptic weights W of each synapse in the network according to the firing status of pre and post-synaptic neurons. This is an in-place operation that modifies the input AbstractSparseSynapse object c.\n\nArguments\n\nc::AbstractSparseSynapse: The current spiking synapse object which contains data structures to represent the synapse network.\nparam::iSTDPRate: Parameters needed for the iSTDP model, including learning rate η, target rate r, STDP time constant τy, maximal and minimal synaptic weight (Wmax and Wmin).\ndt::Float32: The time step for the numerical integration.\n\nAlgorithm\n\nFor each pre-synaptic neuron, if it fires, it reduces the synaptic weight by an amount proportional to the difference between the target rate and the actual rate and increases the inhibitory term,  otherwise the inhibitory term decays exponentially over time with a time constant τy.\nFor each post-synaptic neuron, if it fires, it increases the synaptic weight by an amount proportional to the pre-synaptic trace and increases the excitatory term, otherwise the excitatory term decays exponentially over time with a time constant τy.\nThe synaptic weights are bounded by Wmin and Wmax.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.plasticity!-Tuple{SNNModels.AggregateScaling, SNNModels.AggregateScalingParameter, Float32, SNNModels.Time}","page":"API References","title":"SNNModels.plasticity!","text":"plasticity!(c::SynapseNormalization, param::AdditiveNorm, dt::Float32)\n\nUpdates the synaptic weights using additive or multiplicative normalization (operator). This function calculates  the rate of change μ as the difference between initial weight W0 and the current weight W1,  normalized by W1. The weights are updated at intervals specified by time constant τ.\n\nArguments\n\nc: An instance of SynapseNormalization.\nparam: An instance of AdditiveNorm.\ndt: Simulation time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.plasticity!-Tuple{SNNModels.SynapseNormalization, SNNModels.NormParam, Float32, SNNModels.Time}","page":"API References","title":"SNNModels.plasticity!","text":"plasticity!(c::SynapseNormalization, param::AdditiveNorm, dt::Float32)\n\nUpdates the synaptic weights using additive or multiplicative normalization (operator). This function calculates  the rate of change μ as the difference between initial weight W0 and the current weight W1,  normalized by W1. The weights are updated at intervals specified by time constant τ.\n\nArguments\n\nc: An instance of SynapseNormalization.\nparam: An instance of AdditiveNorm.\ndt: Simulation time step.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.population_indices-Tuple{Any}","page":"API References","title":"SNNModels.population_indices","text":"population_indices(P, type = \"ˆ\")\n\nGiven a dictionary P containing population names as keys and population objects as values, this function returns a named tuple indices that maps each population name to a range of indices. The range represents the indices of the neurons belonging to that population.\n\nArguments\n\nP: A dictionary containing population names as keys and population objects as values.\ntype: A string specifying the type of population to consider. Only population names that contain the specified type will be included in the output. Defaults to \"ˆ\".\n\nReturns\n\nA named tuple indices where each population name is mapped to a range of indices.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.print_model","page":"API References","title":"SNNModels.print_model","text":"print_model(model)\n\nPrints the details of the given model.  The model is expected to have three components: pop (populations), syn (synapses), and stim (stimuli).\n\nThe function displays a graph representation of the model, followed by detailed information about each component.\n\nArguments\n\nmodel: The model containing populations, synapses, and stimuli to be printed.\n\nOutputs\n\nPrints the graph of the model, along with the name, key, type, and parameters of each component in the populations, synapses, and stimuli.\n\nException\n\nRaises an assertion error if any component in the populations is not a subtype of AbstractPopulation, if any component in the synapses is not a subtype of AbstractConnection, or if any component in the stimuli is not a subtype of AbstractStimulus.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.print_summary-Tuple{Any}","page":"API References","title":"SNNModels.print_summary","text":"print_summary(p)\n\nPrints a summary of the given element.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.record_fire!-Tuple{Vector{Bool}, Dict{Symbol, AbstractVector}, SNNModels.Time, Dict{Symbol, Vector{Int64}}}","page":"API References","title":"SNNModels.record_fire!","text":"record_fire!(obj::PT, T::Time, indices::Dict{Symbol,Vector{Int}}) where {PT <: Union{AbstractPopulation, AbstractStimulus}}\n\nRecord the firing activity of the obj object into the obj.records[:fire] array.\n\nArguments\n\nobj::PT: The object to record the firing activity from.\nT::Time: The time at which the recording is happening.\nindices::Dict{Symbol,Vector{Int}}: A dictionary containing indices for each variable to record.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.record_sym!-Tuple{Any, Any, Symbol, SNNModels.Time, Dict{Symbol, Vector{Int64}}, Float32}","page":"API References","title":"SNNModels.record_sym!","text":"record_sym!(obj, key::Symbol, T::Time, indices::Dict{Symbol,Vector{Int}})\n\nRecord the variable key of the obj object into the obj.records[key] array.\n\nArguments\n\nobj: The object to record the variable from.\nkey::Symbol: The key of the variable to record.\nT::Time: The time at which the recording is happening.\nindices::Dict{Symbol,Vector{Int}}: A dictionary containing indices for each variable to record.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.relative_time!-Tuple{Vector{Vector{Float32}}, Any}","page":"API References","title":"SNNModels.relative_time!","text":"relative_time(spiketimes::Spiketimes, start_time)\n\nReturn the spiketimes relative to the start_time of the interval\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.sample_spikes-Union{Tuple{R}, Tuple{Any, Vector, R}} where R<:AbstractRange","page":"API References","title":"SNNModels.sample_spikes","text":"sample_spikes(N, rate::Vector, interval::R; dt=0.125f0) where {R <: AbstractRange}\n\nGenerate sample spike times for N neurons from a rate vector. The function generates spike times for each neuron based on the rate vector and the time interval. The spike times are generated such that during the interval of the rate, the number of spikes is Poisson distributed with the rate.\n\nArguments\n\nN: The number of neurons.\nrate::Vector: The vector with the rate to be sampled.\ninterval::R: The time interval over which the rate is recorded.\ndt=0.125f0: The time step size.\n\nReturns\n\nAn array of spike times for each neuron.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.sim!-Union{Tuple{Vector{TP}}, Tuple{TS}, Tuple{TC}, Tuple{TP}, Tuple{Vector{TP}, Vector{TC}}, Tuple{Vector{TP}, Vector{TC}, Vector{TS}}} where {TP<:SNNModels.AbstractPopulation, TC<:SNNModels.AbstractConnection, TS<:SNNModels.AbstractStimulus}","page":"API References","title":"SNNModels.sim!","text":"sim!(\n    P::Vector{TN},\n    C::Vector{TS};\n    dt = 0.1f0,\n    duration = 10.0f0,\n    pbar = false,\n) where {TN <: AbstractPopulation, TS<:AbstractConnection }\n\nSimulates the spiking neural network for a specified duration by repeatedly calling sim! function.\n\nArguments\n\nP::Vector{TN}: Vector of neurons in the network.\nC::Vector{TS}: Vector of synapses in the network.\ndt::Float32: Time step for the simulation. Default value is 0.1f0.\nduration::Float32: Duration of the simulation. Default value is 10.0f0.\npbar::Bool: Flag indicating whether to display a progress bar during the simulation. Default value is false.\n\nDetails\n\nThe function creates a range of time steps from 0.0f0 to duration-dt with a step size of dt.\nIf pbar is true, the function creates a progress bar using the ProgressBar function with the time step range. Otherwise, it uses the time step range directly.\nThe function iterates over the time steps and calls the sim! function with P, C, and dt.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spatial_activity-Tuple{Any, Any}","page":"API References","title":"SNNModels.spatial_activity","text":"spatial_activity(points, activity; N, L, grid_size=(x=0.1, y=0.1))\n\nCompute the spatial average of activity data over a grid.\n\nArguments\n\npoints::Tuple{Vector{Float64}, Vector{Float64}}: A tuple containing two vectors xs and ys, which represent the x and y coordinates of the points.\nactivity::Matrix{Float64}: A matrix where rows correspond to points and columns correspond to activity values over time.\nN::Int: The number of time steps to group together for averaging.\nL::Float64: The size of each grid cell in both x and y directions.\ngrid_size::NamedTuple{(:x, :y), Tuple{Float64, Float64}} (optional): The total size of the grid in the x and y directions. Defaults to (x=0.1, y=0.1).\n\nReturns\n\nspatial_avg::Array{Float64, 3}: A 3D array where the first two dimensions correspond to the grid cells in the x and y directions, and the third dimension corresponds to the time groups. Each element contains the average activity for the points within the corresponding grid cell and time group.\nx_range::Vector{Float64}: A vector representing the range of x coordinates for the grid cells.\ny_range::Vector{Float64}: A vector representing the range of y coordinates for the grid cells.\n\nDetails\n\nThe function divides the spatial domain into a grid based on the grid_size and L parameters. For each grid cell, it computes the average activity of the points that fall within the cell over time groups defined by N. If no points are found in a grid cell, the average for that cell is skipped.\n\nExample\n\nxs = [0.05, 0.15, 0.25, 0.35]\nys = [0.05, 0.15, 0.25, 0.35]\npoints = (xs, ys)\nactivity = rand(4, 100)  # Random activity data for 4 points over 100 time steps\nN = 10\nL = 0.1\ngrid_size = (x=0.4, y=0.4)\n\nspatial_avg, x_range, y_range = spatial_activity(points, activity; N, L, grid_size)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spikecount-Union{Tuple{Q}, Tuple{T}, Tuple{T, Q, Vector{Int64}}} where {T<:SNNModels.AbstractPopulation, Q<:(AbstractVector)}","page":"API References","title":"SNNModels.spikecount","text":"spikecount(model, Trange, neurons)\n\nReturn the total number of spikes of the neurons in the selected interval\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spikes_in_interval","page":"API References","title":"SNNModels.spikes_in_interval","text":"spikesininterval(spiketimes::Spiketimes, interval::AbstractRange)\n\nReturn the spiketimes in the selected interval\n\nArguments\n\nspiketimes::Spiketimes: Vector with each neuron spiketime interval: 2 dimensional array with the start and end of the interval\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.spiketimes-Tuple{Any}","page":"API References","title":"SNNModels.spiketimes","text":"spiketimes(Ps; kwargs...)\n\nReturn the spiketimes of each population in single vector of Spiketimes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spiketimes-Tuple{T} where T<:Union{SNNModels.AbstractPopulation, SNNModels.AbstractStimulus}","page":"API References","title":"SNNModels.spiketimes","text":"spiketimes(p, interval = nothing, indices = nothing)\n\nCompute the spike times of a population.\n\nArguments:\n\np: The network parameters.\ninterval: The time interval within which to compute the spike times. If nothing, the interval is set to (0, firing_time[end]).\n\nReturns:\n\nspiketimes: A vector of vectors containing the spike times of each neuron.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spiketimes_from_bool-Tuple{Any}","page":"API References","title":"SNNModels.spiketimes_from_bool","text":"spiketimes_from_bool(P, τ; dt = 0.1ms)\n\nThis function takes in the records of a neural population P and time constant τ to calculate spike times for each neuron.\n\nArguments\n\nP: A data structure containing the recorded data of a neuronal population.\nτ: A time constant parameter.\n\nKeyword Arguments\n\ndt: The time step used for the simulation, defaults to 0.1 milliseconds.\n\nReturns\n\nspiketimes: An object of type Spiketimes which contains the calculated spike times of each neuron.\n\nExamples\n\njulia\nspiketimes = spike_times(population_records, time_constant)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.spiketimes_split-Tuple{Any}","page":"API References","title":"SNNModels.spiketimes_split","text":"spiketimes_split(Ps; kwargs...)\n\nReturn the spiketimes of each population in a vector of Spiketimes.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.st_order-Tuple{T} where T<:(Vector)","page":"API References","title":"SNNModels.st_order","text":"st_order(spiketimes::Spiketimes)\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.stimulate!-Tuple{SNNModels.BalancedStimulus, SNNModels.BalancedStimulusParameter, SNNModels.Time, Float32}","page":"API References","title":"SNNModels.stimulate!","text":"stimulate!(p::BalancedStimulus, param::BalancedParameter, time::Time, dt::Float32)\n\nGenerate a Balanced stimulus for a postsynaptic population.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.subpopulations","page":"API References","title":"SNNModels.subpopulations","text":"subpopulations(stim)\n\nExtracts the names and the neuron ids projected from a given set of stimuli.\n\nArguments\n\nstim: A dictionary containing stimulus information.\n\nReturns\n\nnames: A vector of strings representing the names of the subpopulations.\npops: A vector of arrays representing the populations of the subpopulations.\n\nExample\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.synapsearray","page":"API References","title":"SNNModels.synapsearray","text":"Convert a Synapse to a SynapseArray.\n\nArguments\n\nsyn::Synapse: The Synapse object\nindices::Vector: Optional vector of indices to include in the SynapseArray\n\nReturns\n\nSynapseArray: The SynapseArray object\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNModels.synapsearray-Tuple{Vector{SNNModels.Receptor{Float32}}}","page":"API References","title":"SNNModels.synapsearray","text":"Return the SynapseArray as is.\n\nArguments\n\nsyn::SynapseArray: The SynapseArray object\n\nReturns\n\nSynapseArray: The SynapseArray object\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.train!-Union{Tuple{Vector{TP}}, Tuple{TS}, Tuple{TC}, Tuple{TP}, Tuple{Vector{TP}, Vector{TC}}, Tuple{Vector{TP}, Vector{TC}, Vector{TS}}} where {TP<:SNNModels.AbstractPopulation, TC<:SNNModels.AbstractConnection, TS<:SNNModels.AbstractStimulus}","page":"API References","title":"SNNModels.train!","text":"train!(\n    P::Vector{TN},\n    C::Vector{TS};\n    dt = 0.1ms,\n    duration = 10ms,\n) where {TN <: AbstractPopulation, TS<:AbstractConnection }\n\nTrains the spiking neural network for a specified duration by repeatedly calling train! function.\n\nArguments\n\nP::Vector{TN}: Vector of neurons in the network.\nC::Vector{TS}: Vector of synapses in the network.\ndt::Float32: Time step for the training. Default value is 0.1ms.\nduration::Float32: Duration of the training. Default value is 10ms.\n\nDetails\n\nThe function converts dt to Float32 if it is not already.\nThe function creates a progress bar using the ProgressBar function with a range of time steps from 0.0f0 to duration-dt with a step size of dt.\nThe function iterates over the time steps and calls the train! function with P, C, and dt.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.update_time!-Tuple{SNNModels.Time, Float32}","page":"API References","title":"SNNModels.update_time!","text":"update_time!(T::Time, dt::Float32)\n\nUpdate the current time and time step.\n\nArguments\n\nT::Time: The Time object.\ndt::Float32: The time step size.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.α_synapse-Tuple{Any, Any}","page":"API References","title":"SNNModels.α_synapse","text":"Calculate the alpha factor for a synapse given rise and decay time constants.\n\nArguments\n\nτr: Rise time constant\nτd: Decay time constant\n\nReturns\n\nFloat32: The alpha factor\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#Plots","page":"API References","title":"Plots","text":"","category":"section"},{"location":"api_reference/#SNNPlots.dendrite_gplot-Tuple{Any, Any}","page":"API References","title":"SNNPlots.dendrite_gplot","text":"dendrite_gplot(population, target; sym_id=1, r, dt, param=:dend_syn, nmda=true, kwargs...)\n\nPlot the synaptic current in the dendrite of a population of neurons. \nThe function uses the synaptic conductance and the membrane potential to calculate the synaptic current.\n\nParameters\n----------\npopulation : AbstractPopulation\n    The population of neurons to plot\ntarget : Symbol\n    The target of the plot, either `:d` for single dendrite or `:d1/:d2` \nneuron : Int\n    The neuron to plot\nr : Array{Int}\n    The time range to plot\nnmda : Bool\n    If true, the NMDA conductance is used to calculate the synaptic current\nkwargs... : Any\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.mutual_EI_connections","page":"API References","title":"SNNPlots.mutual_EI_connections","text":"mutual_EI_connections(synapses, pre, post)\n\nThis function calculates the mutual and unidirectional connections between two populations of neurons, where one population inhibits the other. The function takes a synapses object as input, which contains the synaptic weights between the two populations.\n\nArguments\n\nsynapses: A struct containing the synaptic weights between the two populations of neurons.\n\nOutput\n\nmutual: An array containing the weights of the mutual connections.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#SNNPlots.plot_activity-Tuple{Any, Any}","page":"API References","title":"SNNPlots.plot_activity","text":"plot_activity(network, Trange)\n\nPlot the activity of a spiking neural network with one dendritic excitatory population and two inhibitory populations. The function plots the firing rate of the populations, the membrane potential of the neurons, the synaptic conductance in the dendrite, the synaptic current in the dendrite, and the raster plot of the excitatory population.\n\nArguments:\n\nnetwork: The spiking neural network object.\nTrange: The time range for plotting.\n\nReturns:\n\nNothing.\n\nExample:\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.plot_average_word_activity-NTuple{4, Any}","page":"API References","title":"SNNPlots.plot_average_word_activity","text":"plot_average_word_activity(sym, word, model, seq; target=:d, before=100ms, after=300ms, zscore=true)\n\nPlot the value of the `sym` variable for the neurons associated to the `word` stimulus. \n`neurons = getneurons(model.stim, seq.symbols.words[w], target)`\n\nArguments:\n- `sym`: The variable to plot.\n- `word`: The word stimulus.\n- `model`: The spiking neural network model.\n- `seq`: The sequence of stimuli.\n- `target`: The target compartment (default=:d).\n- `before`: The time before the stimulus (default=100ms).\n- `after`: The time after the stimulus (default=300ms).\n- `zscore`: Whether to z-score the activity (default=true).\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.plot_network_plasticity-Tuple{Any, Any}","page":"API References","title":"SNNPlots.plot_network_plasticity","text":"plot_network_plasticity(model, simtime; interval = nothing, ΔT=1s, every=1)\n\nPlot the network activity with (raster plot and average firing rate_ and the synaptic weight dynamics\n\nArguments:\n- `model`: the model to plot\n- `simtime`: the simulation time object\n- `interval`: the interval to plot the firing rate and synaptic weight dynamics\n- `ΔT`: the time window to plot the raster plot\n- `every`: plot 1 out of `every` spikes in the raster plot\n\nIf `interval` is not provided, the function will plot the last 10 seconds of the simulation time\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.plot_weights-Tuple{Any}","page":"API References","title":"SNNPlots.plot_weights","text":"plot_weights(network)\n\nPlot the synaptic weights of:     - inhibitory to excitatory neurons     - correlation of synaptic weights between inhibitory and excitatory neurons     - distribution of firing rates of the network\n\nArguments\n\nnetwork: The spiking neural network object.\n\nReturns\n\nplot: The plot object.\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.soma_gplot-Tuple{Any}","page":"API References","title":"SNNPlots.soma_gplot","text":"soma_gplot( population, target; neuron=1, r, dt, param=:soma_syn, nmda=true, ax=plot(), kwargs...)\n\nPlot the synaptic current in the soma of a population of neurons.\nThe function uses the synaptic conductance and the membrane potential to calculate the synaptic current.\n\nParameters\n----------\npopulation : AbstractPopulation\n    The population of neurons to plot\nneuron : Int\n    The neuron to plot\nr : Array{Int}:\n    The time range to plot\nparam : Symbol\n    The parameter to use for the synaptic conductance\nax : Plots.Plot\n    Plot over the current axis\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.stdp_kernel-Tuple{Any}","page":"API References","title":"SNNPlots.stdp_kernel","text":"stdp_kernel(stdp_param; ΔT= -97.5:5:100ms)\n\nPlot the STDP kernel for the given STDP parameters. \n\n# Arguments\n- `stdp_param::STDPParameter`: STDP parameters\n- `ΔT::Array{Float32}`: Arrays of time differences between pre and post-synaptic spikes\n\n# Return\n- `Plots.Plot`: Plot of the STDP kernel\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNPlots.stp_plot","page":"API References","title":"SNNPlots.stp_plot","text":"stp_plot(model, interval, assemblies)\n\nPlot the activity of a spiking neural network with short-term plasticity. The function plots the membrane potential, the firing rate, the synaptic weights, and the raster plot of the excitatory population.\n\n\n\n\n\n","category":"function"},{"location":"api_reference/#Other-types","page":"API References","title":"Other types","text":"","category":"section"},{"location":"api_reference/#SNNModels.AbstractConnectionParameter","page":"API References","title":"SNNModels.AbstractConnectionParameter","text":"AbstractConnectionParameter <: AbstractParameter\n\nAn abstract type representing a connection parameter.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.AbstractParameter","page":"API References","title":"SNNModels.AbstractParameter","text":"AbstractParameter\n\nAn abstract type representing a parameter.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.AbstractPopulationParameter","page":"API References","title":"SNNModels.AbstractPopulationParameter","text":"AbstractPopulationParameter <: AbstractParameter\n\nAn abstract type representing a population parameter.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.AbstractStimulusParameter","page":"API References","title":"SNNModels.AbstractStimulusParameter","text":"AbstractStimulusParameter <: AbstractParameter\n\nAn abstract type representing a stimulus parameter.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.AdditiveNorm","page":"API References","title":"SNNModels.AdditiveNorm","text":"AdditiveNorm{FT = Float32} <: NormParam\n\nThis struct holds the parameters for additive normalization.  It includes a timescale τ (default 0.0) and an operator (default addition).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.DendNeuronParameter","page":"API References","title":"SNNModels.DendNeuronParameter","text":"DendNeuronParameter{FT, IT, DT, ST, NMDAT, PST, PT}\n\nA parameter struct for the Tripod neuron model, implementing an Adaptive Exponential Integrate-and-Fire (AdEx) model with dendritic compartments.\n\nFields\n\nC::FT: Membrane capacitance (default: 281pF)\ngl::FT: Leak conductance (default: 40nS)\nR::FT: Total membrane resistance (default: nS/gl * GΩ)\nτm::FT: Membrane time constant (default: C/gl)\nEr::FT: Resting potential (default: -70.6mV)\nVr::FT: Reset potential (default: -55.6mV)\nVt::FT: Rheobase threshold (default: -50.4mV)\nΔT::FT: Slope factor (default: 2mV)\nτw::FT: Adaptation current time constant (default: 144ms)\na::FT: Subthreshold adaptation conductance (default: 4nS)\nb::FT: Spike-triggered adaptation increment (default: 80.5pA)\nAP_membrane::FT: After-potential membrane parameter (default: 10.0f0mV)\nBAP::FT: Backpropagating action potential parameter (default: 1.0f0mV)\nup::FT: Spike upstroke duration (default: 1ms)\nτabs::FT: Absolute refractory period (default: 2ms)\npostspike::PST: Post-spike dynamics (default: PostSpike(A=10, τA=30ms))\nds::DT: Dendritic segment lengths (default: [200um, (200um, 400um)])\nphysiology::PT: Dendritic physiology (default: human_dend)\nsoma_syn::ST: Soma synapse type (default: TripodSomaSynapse)\ndend_syn::ST: Dendritic synapse type (default: TripodDendSynapse)\nNMDA::NMDAT: NMDA voltage dependency parameters (default: NMDAVoltageDependency(mg=MgmM, b=nmdab, k=nmda_k))\n\nType Parameters\n\nFT: Floating-point type for membrane parameters (default: Float32)\nIT: Integer type for time-related parameters (default: Int64)\nDT: Type for dendritic segment lengths (default: Vector{DendLength})\nST: Synapse type (default: Synapse)\nNMDAT: NMDA voltage dependency type (default: NMDAVoltageDependency{Float32})\nPST: Post-spike dynamics type (default: PostSpike{Float32})\nPT: Physiology type (default: Physiology)\n\nExamples\n\njulia> TripodParameter = DendNeuronParameter(ds = [200um, (200um, 400um)])\nDendNeuronParameter{Float32, Int64, Vector{DendLength}, Synapse, NMDAVoltageDependency{Float32}, PostSpike{Float32}, Physiology}(281.0, 40.0, 25.0, 7.03125, -70.6, -55.6, -50.4, 2.0, 144.0, 4.0, 80.5, 10.0, 1.0, 1, 2, PostSpike{Float32}(10, 30.0), [200.0, (200.0, 400.0)], human_dend, TripodSomaSynapse, TripodDendSynapse, NMDAVoltageDependency{Float32}(0.001, 0.062, 3.57))\n\njulia> BallAndStickParameter = DendNeuronParameter(ds = [(150um, 400um)])\nDendNeuronParameter{Float32, Int64, Vector{DendLength}, Synapse, NMDAVoltageDependency{Float32}, PostSpike{Float32}, Physiology}(281.0, 40.0, 25.0, 7.03125, -70.6, -55.6, -50.4, 2.0, 144.0, 4.0, 80.5, 10.0, 1.0, 1, 2, PostSpike{Float32}(10, 30.0), [(150.0, 400.0)], human_dend, TripodSomaSynapse, TripodDendSynapse, NMDAVoltageDependency{Float32}(0.001, 0.062, 3.57))\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Dendrite","page":"API References","title":"SNNModels.Dendrite","text":"Dendrite\n\nA structure representing a dendritic compartment within a neuron model.\n\nFields\n\nEr::FT = -70.6mV: Resting potential.\nC::FT = 10pF: Membrane capacitance.\ngax::FT = 10nS: Axial conductance.\ngm::FT = 1nS: Membrane conductance.\nl::FT = 150um: Length of the dendritic compartment.\nd::FT = 4um: Diameter of the dendrite.\n\nThe type FT represents Float32.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.EmptyParam","page":"API References","title":"SNNModels.EmptyParam","text":"EmptyParam\n\nA struct representing an empty parameter.\n\nFields\n\ntype::Symbol: The type of the parameter, default is :empty.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.GABAergic","page":"API References","title":"SNNModels.GABAergic","text":"GABAergic struct represents a group of GABAergic receptors.\n\nFields\n\nGABAa::T: GABAa receptor\nGABAb::T: GABAb receptor\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Glutamatergic","page":"API References","title":"SNNModels.Glutamatergic","text":"Glutamatergic struct represents a group of glutamatergic receptors.\n\nFields\n\nAMPA::T: AMPA receptor\nNMDA::T: NMDA receptor\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.MultiplicativeNorm","page":"API References","title":"SNNModels.MultiplicativeNorm","text":"MultiplicativeNorm{FT = Int32} <: NormParam\n\nThis struct holds the parameters for multiplicative normalization.  It includes a timescale τ (default 0.0) and an operator (default multiplication).\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.NMDAVoltageDependency","page":"API References","title":"SNNModels.NMDAVoltageDependency","text":"NMDAVoltageDependency struct represents the voltage dependence of NMDA receptors.\n\nFields\n\nb::T: Voltage dependence factor (default: 3.36)\nk::T: Voltage dependence factor (default: -0.077)\nmg::T: Magnesium concentration (default: 1.0)\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.NormParam","page":"API References","title":"SNNModels.NormParam","text":"Abstract type for normalization parameters.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PlasticityVariables","page":"API References","title":"SNNModels.PlasticityVariables","text":"PlasticityVariables\n\nAn abstract type representing plasticity variables.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PoissonStimulusFixed","page":"API References","title":"SNNModels.PoissonStimulusFixed","text":"PoissonStimulusFixed\n\nPoisson stimulus with fixed rate. The rate arrives to all the neuronstargeted\nby the stimulus.\n\n# Fields\n- `rate::Vector{R}`: A vector containing the rate of the Poisson stimulus.\n- `active::Vector{Bool}`: A vector of booleans indicating if the stimulus is active.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PoissonStimulusInterval","page":"API References","title":"SNNModels.PoissonStimulusInterval","text":"PoissonStimulusInterval\n\nPoisson stimulus with rate defined for each cell in the layer. Each neuron of the 'N' Poisson population fires with 'rate' in the intervals defined by 'intervals'.\n\n# Fields\n- `rate::Vector{R}`: A vector containing the rate of the Poisson stimulus.\n- `intervals::Vector{Vector{R}}`: A vector of vectors containing the intervals in which the Poisson stimulus is active.\n- `active::Vector{Bool}`: A vector of booleans indicating if the stimulus is active.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PoissonStimulusLayer","page":"API References","title":"SNNModels.PoissonStimulusLayer","text":"PoissonStimulusLayer\n\nPoisson stimulus with rate defined for each cell in the layer. Each neuron of the 'N' Poisson population fires with 'rate'.\nThe connectivity is defined by the parameter 'ϵ'. Thus, the number of presynaptic neuronsconnected to the postsynaptic neuronsis 'N*ϵ'. Each post-synaptic cell receives rate: 'rate * N * ϵ'.\n\n# Fields\n- `rate::Vector{R}`: A vector containing the rate of the Poisson stimulus.\n- `N::Int32`: The number of neuronsin the layer.\n- `ϵ::Float32`: The fraction of presynaptic neuronsconnected to the postsynaptic neurons.\n- `active::Vector{Bool}`: A vector of booleans indicating if the stimulus is active.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PoissonStimulusVariable","page":"API References","title":"SNNModels.PoissonStimulusVariable","text":"PoissonStimulusVariable\n\nPoisson stimulus with rate defined with a function.\n\n# Fields\n- `variables::Dict{Symbol,Any}`: A dictionary containing the variables for the function.\n- `rate::Function`: A function defining the rate of the Poisson stimulus.\n- `active::Vector{Bool}`: A vector of booleans indicating if the stimulus is active.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.PostSpike","page":"API References","title":"SNNModels.PostSpike","text":"PostSpike\n\nA structure defining the parameters of a post-synaptic spike event.\n\nFields\n\nA::FT: Amplitude of the Post-Synaptic Potential (PSP).\nτA::FT: Time constant of the PSP.\n\nThe type FT represents Float32.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Receptor","page":"API References","title":"SNNModels.Receptor","text":"Receptor struct represents a synaptic receptor with parameters for reversal potential, rise time, decay time, and conductance.\n\nFields\n\nE_rev::T: Reversal potential (default: 0.0)\nτr::T: Rise time constant (default: -1.0)\nτd::T: Decay time constant (default: -1.0)\ng0::T: Maximum conductance (default: 0.0)\ngsyn::T: Synaptic conductance (default: calculated based on g0, τr, and τd)\nα::T: Alpha factor for the differential equation (default: calculated based on τr and τd)\nτr⁻::T: Inverse of rise time constant (default: calculated based on τr)\nτd⁻::T: Inverse of decay time constant (default: calculated based on τd)\nnmda::T: NMDA factor (default: 0.0)\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Spiketimes","page":"API References","title":"SNNModels.Spiketimes","text":"Spiketimes\n\nA type alias for a vector of vectors of Float32, representing spike times.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Synapse","page":"API References","title":"SNNModels.Synapse","text":"Synapse struct represents a synaptic connection with different types of receptors.\n\nFields\n\nAMPA::T: AMPA receptor\nNMDA::T: NMDA receptor (with voltage dependency)\nGABAa::T: GABAa receptor\nGABAb::T: GABAb receptor\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#SNNModels.Synapse-Tuple{SNNModels.Glutamatergic, SNNModels.GABAergic}","page":"API References","title":"SNNModels.Synapse","text":"Construct a Synapse from Glutamatergic and GABAergic receptors.\n\nArguments\n\nglu::Glutamatergic: Glutamatergic receptors\ngaba::GABAergic: GABAergic receptors\n\nReturns\n\nSynapse: A Synapse object\n\n\n\n\n\n","category":"method"},{"location":"api_reference/#SNNModels.Time","page":"API References","title":"SNNModels.Time","text":"struct Time\nTime\n\nA mutable struct representing time.  A mutable struct representing time.\n\nFields\n\nt::Vector{Float32}: A vector containing the current time.\ntt::Vector{Int}: A vector containing the current time step.\ndt::Float32: The time step size.\n\n\n\n\n\n","category":"type"},{"location":"api_reference/#Helper-macros","page":"API References","title":"Helper macros","text":"","category":"section"},{"location":"api_reference/#SNNModels.@load_units-Tuple{}","page":"API References","title":"SNNModels.@load_units","text":"@load_units\nLoad all the units defined in the module into the current scope.\nThis macro generates a block of expressions that assign the unit constants\n    \nThe base units in the module are:\n- cm : centimeters\n- ms : milliseconds\n- kHz : kilohertz\n- mV : millivolts\n- pA : picoamperes\n- pF : picofarads\n- nS : nanosiemens\n- GΩ : gigaohms\n- uM : micromolar\n\nThe derived units in the module are obtained as multiple or division of the base units. \n\nThe standard integration time step is 0.125ms, which is used in the simulation.\n\n\n\n\n\n","category":"macro"},{"location":"api_reference/#SNNModels.@snn_kw-Tuple{Any}","page":"API References","title":"SNNModels.@snn_kw","text":"A minimal implementation of Base.@kwdef with default type parameter support\n\n\n\n\n\n","category":"macro"},{"location":"models_ext/#Models-Extensions","page":"Models Extensions","title":"Models Extensions","text":"","category":"section"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The library allows us to define and simulate models from computational neuroscience easily. The library exposes two functions:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"function sim!(p::Vector{AbstractPopulation}, c::Vector{AbstractConnection}, duration<:Real) end function train!(p::Vector{AbstractConnection}, c:Vector{AbstractConnection}, duration<:Real) end The functions support simulation with and without neural plasticity; the model is defined within the arguments passed to the functions. Models are composed of 'AbstractPopulation' and 'AbstractConnection' arrays.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Any elements of AbstractPopulation must implement the method:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"function integrate!(p, p.param, dt) end Conversely, elements of AbstractConnection must implement the methods:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"function forward!(p, p.param) end function plasticity!(c, c.param, dt) end The library is rich in examples of common neuron models that can be used as a basis.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In the notebook folder, there is a tutorial about how to use SparseMatrices in the SNN framework.","category":"page"},{"location":"examples/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"examples/#AdEx-neuron","page":"Tutorial","title":"AdEx neuron","text":"","category":"section"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"A single neuron under a fixed depolaring current can be modeled with an Adaptive Exponential model, with equations:","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"beginaligned\ntau_m fracdVdt =  (V^s-V_r) + Delta_T expfracV^s-V_tDelta_T - R (w + I) \ntau_wfracdwdt = -w + a (V^s-V_r) + b cdot delta(t-t_spike)\nendaligned","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"This model is implemented in the AdEx neuron model. The AdEx model can reproduce several different firing patterns observed in real neurons under direct current injections in the soma (AdEx firing patterns, Adaptive exponential integrate-and-fire model as an effective description of neuronal activity).  ","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"using SNNPlots\nimport SNNPlots: vecplot, plot\nusing SpikingNeuralNetworks\nusing DataFrames\nSNN.@load_units\n\n# Define the data\ndata = [\n    (\"Tonic\", 20, 0.0, 30.0, 60.0, -55.0, 65),\n    (\"Adapting\", 20, 0.0, 100.0, 5.0, -55.0, 65),\n    (\"Init. burst\",  5.0, 0.5, 100.0, 7.0, -51.0, 65),\n    (\"Bursting\",  5.0, -0.5, 100.0, 7.0, -46.0, 65),\n    # (\"Irregular\", 14.4, -0.5, 100.0, 7.0, -46.0, 65),\n    (\"Transient\", 10, 1.0, 100, 10.0, -60.0, 65),\n    (\"Delayed\", 5.0, -1.0, 100.0, 10.0, -60., 25)\n]\n\n\n\n# Create the DataFrame\ndf = DataFrame(\n    Type = [row[1] for row in data],\n    τm = [row[2] for row in data],\n    a = [row[3] for row in data],\n    τw = [row[4] for row in data],\n    b = [row[5] for row in data],\n    ur = [row[6] for row in data],\n    i = [row[7] for row in data]\n)\n\n# Display the DataFrame","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"Row Type τm a τw b ur i\n1 Tonic 20 0.0 30.0 60.0 -55.0 65\n2 Adapting 20 0.0 100.0 5.0 -55.0 65\n3 Init. burst 5.0 0.5 100.0 7.0 -51.0 65\n4 Bursting 5.0 -0.5 100.0 7.0 -46.0 65\n5 Irregular 14.4 -0.5 100.0 7.0 -46.0 65\n6 Transient 10 1.0 100 10.0 -60.0 65\n7 Delayed 5.0 -1.0 100.0 10.0 -60.0 25","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"plots = map(eachrow(df)) do row\n    param = AdExParameter(\n        R = 0.5GΩ,\n        Vt = -50mV,\n        ΔT = 2mV,\n        El = -70mV,\n        # τabs=0,\n        τm = row.τm * ms,\n        Vr = row.ur * mV,\n        a = row.a * nS,\n        b= row.b * pA,\n        τw = row.τw * ms,\n        At = 0f0\n    )\n\n\n    E = SNN.AdExNeuron(; N = 1, \n        param,\n        )\n    SNN.monitor!(E, [:v, :fire, :w], sr = 8kHz)\n    model = compose(; E = E, silent=true)\n\n    E.I .= Float32(05pA)\n    SNN.sim!(; model, duration = 30ms)\n    E.I .= Float32(row.i)\n    # E.I .= row.i, # Current step\n    SNN.sim!(; model, duration = 300ms)\n\n    default(color=:black)\n    p1 = plot(vecplot(E, :w, ylabel=\"Adapt. current (nA)\"), \n            vecplot(E, :v, add_spikes=true, ylabel=\"Membrane potential (mV)\", ylims=(-80, 10)), \n            title = row.Type,\n            layout = (1,2), \n            size = (600, 800), \n            margin=10Plots.mm)\nend\n\nplot(plots...,  \n    layout = (7, 1), \n    size = (800, 2000), \n    xlabel=\"Time (ms)\", \n    legend=:outerright,\n    leftmargin=15Plots.mm,\n)","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Firing patterns of AdEx neuron)","category":"page"},{"location":"examples/#Noise-input-current","page":"Tutorial","title":"Noise input current","text":"","category":"section"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"In 'in vivo' experiments neurons are driven with noisy inputs that can be modeled by splitting the input current in two components I = Iˆdet(t) + I^noise(t).","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"the neuronal dynamics is then determined (for a generalized Leaky and Integrate model) by the equation:","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"tau_m fracd u d t = f(u) + R I^det(t) + R I^noise(t)","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"In this description the I^noise(t) is the stochastic component of the external current, which is normally assumed to be a white noise.  Under white noise, the average value of the external current is langle I_noise rangle = 0 and the autocorrelation is determined by the neuronal timescale and the noise variance, langle I^noise(t) I^noise(t) rangle = tau_m sigma delta (t-t).","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"To introduce white noise in the model we can use the CurrentNoiseParameter type. In the following example:","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"define a Leaky Integrate-and-Fire neuron ;\ndefine a CurrentNoiseParameter, it accepts a I_base value (the deterministic current) and a distribution, which we set to be a Normal distribution with zero average and 100pA variance;\nCurrentStimulus attaches an <: AbstraactStimulus to the :I variable of the population E;\nrecord the variables, simulate and plot the results.","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"\nimport SNNPlots: vecplot, plot\nusing SpikingNeuralNetworks\nusing Distributions\nSNN.@load_units\n\nif_parameter = SNN.IFParameter(\n    R = 0.5GΩ,\n    Vt = -50mV,\n    ΔT = 2mV,\n    El = -70mV,\n    τm = 20ms,\n    Vr = -55mV,\n)\n\n# Create the IF neuron with tonic firing parameters\nE = SNN.IF(; N = 1, \n    param=if_parameter,\n    )\nSNN.monitor!(E, [:v, :fire, :w, :I], sr = 2kHz)\n\n# Create a withe noise input current \ncurrent_param = CurrentNoiseParameter(E.N; I_base=30pA, I_dist=Normal(00pA, 100pA))\ncurrent = CurrentStimulus(E, :I, param=current_param)\nmodel = compose(; E = E, I=current)\nSNN.sim!(; model, duration = 2000ms)\n\np = plot(\n    vecplot(E, :v, add_spikes=true, ylabel=\"Membrane potential (mV)\", ylims=(-80, 10), c=:black),\n    vecplot(E, :I, ylabel=\"External current (pA)\", c=:gray, lw=0.4, alpha=0.4),\n    layout=(\n        2, 1\n    ),\n    size=(600, 500),\n    xlabel= \"Time (s)\",\n    leftmargin=10Plots.mm,\n)\n","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Noise input current)","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"The library also allows to define an arbitrary complex noise function with the CurrentVariableParameter type. In this case we must define a function, in this case sinusoidal_current, which is called runtime to determine the input current to each neuron in the population, the function must accept three arguments: ","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"a dictionary with the variables::Dict;\nthe time of the model t::Float32;\nthe index of the neuron i::Int32.","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"We thus define the set of variables that the function uses to determine the current and pass them along the function to CurrentVariableParameter. ","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"In the following example we used a plain sinusoidal current that stimulate the two neurons in the population with a phase a frequency of 1Hz and a phase shift of 3/4 π","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"\n\n# Create a populations with 2 IF neurons\nE = SNN.IF(; N = 2, \n    param=if_parameter,\n    )\nSNN.monitor!(E, [:v, :fire, :w, :I], sr = 2kHz)\n\n# Create a withe noise input current \n\nfunction sinusoidal_current(variables::Dict, t::Float32, i::Int)\n    # Extract the parameters from the variables dictionary\n    amplitude = variables[:amplitude]\n    frequency = variables[:frequency]\n    phase = variables[:shift_phase]\n    \n    # Calculate the current value at time t for neuron i\n    return amplitude * sin(2 * π * frequency * t + i*phase)\nend\n\nvariables = Dict(\n    :amplitude => 50pA,\n    :frequency => 1Hz,\n    :shift_phase => π*3/4, # Phase shift for each neuron\n)\n\ncurrent_param = SNN.CurrentVariableParameter(variables, sinusoidal_current )\ncurrent = CurrentStimulus(E, :I, param=current_param)\nmodel = compose(; E = E, I=current)\nSNN.sim!(; model, duration = 2000ms)\n\np = plot(\n    vecplot(E, :v, add_spikes=true, ylabel=\"Membrane potential (mV)\", ylims=(-80, 10)),\n    vecplot(E, :I, ylabel=\"External current (pA)\", c=:gray, lw=0.4, alpha=0.4),\n    layout=(\n        2, 1\n    ),\n    size=(600, 500),\n    xlabel= \"Time (s)\",\n    leftmargin=10Plots.mm,\n)\n","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Variable input current)","category":"page"},{"location":"examples/#Balanced-input-spikes","page":"Tutorial","title":"Balanced input spikes","text":"","category":"section"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"In biophysical networks, and in the brain, neurons' membrane potential is not driven by external currents but by the opening and closing of ionic channels following an afferent spike. Spikes cause the release of vescicles in the synaptic cleft that bind to the ionic channels on the post-synaptic neuron's membrane.  The opening of a ionic channel can lead to a depolarizing or hyperpolarizing current, dependently on its reversal potential. ","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"In this example we use two spike trains, an excitatory and an inhibitory one, to stimulate a Leaky Integrate-and-Fire neuron above the spike-threshold. The large number of spikes received increases the synaptic conductance of the cell, to the point that it dominates over the leakage conductance term. In this condition, the neurons membrane dynamics is dominated by the external inputs, and the neuron is in the so-called \"High-conductance state\". ","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"using SpikingNeuralNetworks\nusing SNNPlots\nimport SNNPlots: vecplot, plot, savefig, gplot\nSNN.@load_units\n\nif_parameter = SNN.IFParameter(\n    R = 0.5GΩ,\n    Vt = -50mV,\n    ΔT = 2mV,\n    El = -70mV,\n    τm = 20ms,\n    Vr = -55mV,\n    E_i = -75mV,\n    E_e = 0mV,\n)\n\n# Create the IF neuron\n# E = SNN.AdEx(; N = 1, \n#     # param=if_parameter,\n#     )\nE = SNN.IF(; N = 1, \n    param=if_parameter,\n    )\n\n# Create an excitatory and inhibitory spike trains\n\n# Define the Poisson stimulus parameters \npoisson_exc = SNN.PoissonStimulusLayer(\n    1.2Hz,    # Mean firing rate (Hz) \n    p = 1f0,  # Probability of connecting to a neuron\n    μ = 1.0,  # Synaptic strength (nS)\n    N = 1000, # Neurons in the Poisson Layer\n)\n\npoisson_inh = SNN.PoissonStimulusLayer(\n    3Hz,       # Mean firing rate (Hz)\n    p = 1f0,   # Probability of connecting to a neuron\n    μ = 4.0,   # Synaptic strength (nS)\n    N = 1000,  # Neurons in the Poisson Layer\n)\n\n# Create the Poisson layers for excitatory and inhibitory inputs\nstim_exc = PoissonLayer(E, :ge, param=poisson_exc, name=\"noiseE\")\nstim_inh = PoissonLayer(E, :gi, param=poisson_inh, name=\"noiseI\")\n\n# Create the model and run the simulation\nmodel = compose(; E = E, stim_exc, stim_inh)\nSNN.monitor!(E, [:v, :fire, :w, :ge, :gi], sr = 2kHz)\nSNN.monitor!(model.stim, [:fire])\nSNN.sim!(; model, duration = 1000ms)\n\n# Plot the results\n# gplot is a special function the plots the synaptic currents\n\nSNNPlots.default(palette=:okabe_ito)\np = plot(\n    raster(model.stim),\n    gplot(E, v_sym=:v, ge_sym=:ge, gi_sym=:gi, \n        Ee_rev=0mV, Ei_rev=-75mV,\n        ylabel=\"Synapti current (μA)\"),\n    vecplot(E, :v, add_spikes=true, ylabel=\"Membrane potential (mV)\", ylims=(-80, 10), c=:black),\n    layout=(\n        3, 1\n    ),\n    fgcolorlegend=:transparent,\n    size=(800, 900),\n    xlabel= \"Time (s)\",\n    leftmargin=10SNNPlots.Plots.mm,\n)","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Poisson input)","category":"page"},{"location":"examples/#Ball-and-Stick-neuron","page":"Tutorial","title":"Ball and Stick neuron","text":"","category":"section"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"We can also implement more complex cellular models. A classical extension of the single-compartment cell, or point-neuron, is the ball-and-stick neuron. This model has a passive dendritic compartment and an active, non-linear soma.  In our case, the dendritic compartment can be endowed with synaptic non-linearities, such as the NMDA receptor voltage-dependence. The following example implements a ball and stick model with a steep dendritic non-linearity. The cell is stimulated with balanced excitatory-inhibitory inputs on the denrite.","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"using SpikingNeuralNetworks\nusing Plots\nusing Random\nSNN.@load_units\nimport SpikingNeuralNetworks: Synapse, Receptor, Glutamatergic, GABAergic, DendNeuronParameter, synapsearray, get_time\n\nusing BenchmarkTools\n\nRandom.seed!(1234)\n## Define the neuron model parameters\n# Define the synaptic properties for the soma and dendrites\nSomaSynapse = Synapse(\n    AMPA = Receptor(E_rev = 0.0, \n                    τr = 0.26, \n                    τd = 2.0, \n                    g0 = 0.73),\n    GABAa = Receptor(E_rev = -70.0, \n                     τr = 0.1, \n                     τd = 15.0, \n                     g0 = 0.38)\n    # SomaSynapse has not NMDA and GABAb receptors, \n    # they are assigned to a NullReceptor and skipped at simulation time\n)\n\nDendSynapse = Synapse(\n    AMPA = Receptor(E_rev = 0.0, τr = 0.26, τd = 2.0, g0 = 0.73),\n    NMDA = Receptor(E_rev = 0.0, τr = 8, τd = 35.0, g0 = 1.31, nmda = 1.0f0),\n    GABAa = Receptor(E_rev = -70.0, τr = 4.8, τd = 29.0, g0 = 0.27),\n    GABAb = Receptor(E_rev = -90.0, τr = 30, τd = 400.0, g0 = 0.0006), \n)\n\nNMDA = let\n    Mg_mM = 1.0mM\n    nmda_b = 3.36   # voltage dependence of nmda channels\n    nmda_k = -0.077     # Eyal 2018\n    SNN.NMDAVoltageDependency(mg = Mg_mM/mM, b = nmda_b, k = nmda_k)\nend\n\n# We then define the dendritic neuron model. The dendritic neuron holds has the soma and dendritic compartments parameters, and the synaptic properties for both compartments. \ndend_neuron = DendNeuronParameter(\n    # adex parameters\n    C = 281pF,\n    gl = 40nS,\n    Vr = -55.6,\n    Er = -70.6,\n    ΔT = 2,\n    Vt = -50.4,\n    a = 4,\n    b = 80.5pA,\n    τw = 144,\n    up = 0.1ms,\n    τabs = 0.1ms,\n\n    # post-spike adaptation\n    postspike = SNN.PostSpike(A= 10.0, τA= 30.0), \n\n    # synaptic properties\n    soma_syn = SomaSynapse,\n    dend_syn = DendSynapse,\n    NMDA = NMDA,\n\n    # dendrite\n    ds = [160um],\n    physiology = SNN.human_dend,\n)\n\nE = SNN.SNNModels.BallAndStick(N=1, param = dend_neuron)\n\npoisson_exc = SNN.PoissonStimulusLayer(\n    10.2Hz,    # Mean firing rate (Hz) \n    p = 1f0,  # Probability of connecting to a neuron\n    μ = 1.0,  # Synaptic strength (nS)\n    N = 1000, # Neurons in the Poisson Layer\n)\n\npoisson_inh = SNN.PoissonStimulusLayer(\n    3Hz,       # Mean firing rate (Hz)\n    p = 1f0,   # Probability of connecting to a neuron\n    μ = 4.0,   # Synaptic strength (nS)\n    N = 1000,  # Neurons in the Poisson Layer\n)\n\n# Create the Poisson layers for excitatory and inhibitory inputs\nstim_exc = SNN.PoissonLayer(E, :glu, :d, param=poisson_exc, name=\"noiseE\")\nstim_inh = SNN.PoissonLayer(E, :gaba, :d, param=poisson_inh, name=\"noiseI\")\n\nmodel = SNN.compose(;E, stim_exc, stim_inh)\nSNN.monitor!(E, [:v_s, :v_d, :fire, :g_s, :g_d], sr=1000Hz)\n\n#\nPlots.default(palette = :okabe_ito)\nSNN.sim!(model, 3s)\np = SNN.vecplot(E, :v_d, sym_id=1, interval=1:2ms:get_time(model), neurons=1, label=\"Dendritic Compartment\")\nSNN.vecplot!(p, E, :v_s, sym_id=2, interval=1:2ms:get_time(model), neurons=1, add_spikes=true, label=\"Soma Compartment\")\nplot!(ylims=:auto, legend=:outertop, legendfontsize=12, xlabel=\"Time (s)\", ylabel=\"Voltage (mV)\", title=\"Ball and Stick Neuron Model\")","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Ball-and-Stick)","category":"page"},{"location":"examples/#Recurrent-EI-network","page":"Tutorial","title":"Recurrent EI network","text":"","category":"section"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"using DrWatson\nusing Plots\nusing UnPack\nusing SpikingNeuralNetworks\nSNN.@load_units\n##\n\nZerlaut2019_network = (Npop = (E=8000, I=2000),\n    exc = IFParameterSingleExponential(\n                τm = 200pF / 10nS, \n                El = -70mV, \n                Vt = -50.0mV, \n                Vr = -70.0f0mV,\n                R  = 1/10nS, \n                τabs = 2ms,       \n                τi=5ms,\n                τe=5ms,\n                E_i = -80mV,\n                E_e = 0mV,\n                ),\n\n    inh = IFParameterSingleExponential(\n                τm = 200pF / 10nS, \n                El = -70mV, \n                Vt = -53.0mV, \n                Vr = -70.0f0mV,\n                R  = 1/10nS, \n                τabs = 2ms,       \n                τi=5ms,\n                τe=5ms,\n                E_i = -80mV,\n                E_e = 0mV,\n                ),\n\n    connections = (\n        E_to_E = (p = 0.05, μ = 2nS),\n        E_to_I = (p = 0.05, μ = 2nS),\n        I_to_E = (p = 0.05, μ = 10nS),\n        I_to_I = (p = 0.05, μ = 10nS),\n        ),\n    \n    afferents = (\n        N = 100,\n        p = 0.1f0,\n        rate = 20Hz,\n        μ = 4.0,\n        ), \n)\n\nfunction network(config)\n    @unpack afferents, connections, Npop = config\n    E = IF(N=Npop.E, param=config.exc, name=\"E\")\n    I = IF(N=Npop.I, param=config.inh, name=\"I\")\n\n    AfferentParam = PoissonStimulusLayer(afferents.rate; afferents...)\n    afferentE = PoissonLayer(E, :ge, param=AfferentParam, name=\"noiseE\")\n    afferentI = PoissonLayer(I, :ge, param=AfferentParam, name=\"noiseI\")\n\n    synapses = (\n        E_to_E = SpikingSynapse(E, E, :ge, p=connections.E_to_E.p, μ=connections.E_to_E.μ, name=\"E_to_E\"),\n        E_to_I = SpikingSynapse(E, I, :ge, p=connections.E_to_I.p, μ=connections.E_to_I.μ, name=\"E_to_I\"),\n        I_to_E = SpikingSynapse(I, E, :gi, p=connections.I_to_E.p, μ=connections.I_to_E.μ, name=\"I_to_E\"),\n        I_to_I = SpikingSynapse(I, I, :gi, p=connections.I_to_I.p, μ=connections.I_to_I.μ, name=\"I_to_I\"),\n    )\n    model = compose(;E,I, afferentE, afferentI, synapses..., silent=true, name=\"Balanced network\") \n    monitor!(model.pop, [:fire])\n    monitor!(model.stim, [:fire])\n    # monitor!(model.pop, [:v], sr=200Hz)\n    return compose(;model..., silent=true)\nend\n\n\n##\nplots = map([4, 10]) do input_rate\n    config = @update Zerlaut2019_network begin\n        afferents.rate = input_rate*Hz\n    end \n    model = network(config)\n    sim!(;model, duration=10_000ms,  pbar=true)\n    pr= raster(model.pop, every=40)\n\n    # Firing rate of the network with a fixed afferent rate\n    frE, r = firing_rate(model.pop.E, interval=3s:10s, pop_average=true)\n    frI, r = firing_rate(model.pop.I, interval=3s:10s, pop_average=true)\n    pf = plot(r, [frE, frI], labels=[\"E\" \"I\"],\n        xlabel=\"Time (s)\", ylabel=\"Firing rate (Hz)\", \n        title=\"Afferent rate: $input_rate Hz\",\n        size=(600, 400), lw=2)\n\n    # Plot the raster plot of the network\n    plot(pf, pr, layout=(2, 1))\nend\n\nplot(plots..., layout=(1,2), size=(1200, 600), xlabel=\"Time (s)\", leftmargin=10Plots.mm)\n##","category":"page"},{"location":"examples/","page":"Tutorial","title":"Tutorial","text":"(Image: Recurrent network)","category":"page"},{"location":"examples/#FORCE-learning","page":"Tutorial","title":"FORCE learning","text":"","category":"section"},{"location":"examples/#Recurrent-network-with-dendrites","page":"Tutorial","title":"Recurrent network with dendrites","text":"","category":"section"},{"location":"examples/#Working-memory-with-synaptic-plasticity","page":"Tutorial","title":"Working memory with synaptic plasticity","text":"","category":"section"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"#SpikingNeuralNetworks.jl-Documentation","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Julia Spiking Neural Networks (JuliaSNN) is a library for simulating biophysical neuronal network models. ","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"This documentation is work in progress; please contact me via the GitHub repository if you have any specific questions or want to collaborate! ","category":"page"},{"location":"#Simple-and-powerful-simulation-framework","page":"SpikingNeuralNetworks.jl Documentation","title":"Simple and powerful simulation framework","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"The library's strength points are:","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Modular, intuitive, and quick instantiation of complex biophysical models;\nLarge pool of standard models already available and easy implementation of custom new models;\nHigh performance and native multi-threading support, laptop and cluster-friendly;\nAccess to all models' variables at runtime and save-load-rerun of arbitrarily complex networks;\nGrowing ecosystem for stimulation protocols, network analysis, and visualization (SNNUtils, SNNPlots, SNNGeometry).","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"SpikingNeuralNetworks.jl leverages the JuliaSNN ecosystem, which offers SNNPlots to plot models' recordings and SNNUtils for further stimulation protocols and analysis.","category":"page"},{"location":"#Models:-populations,-connections,-and-stimuli","page":"SpikingNeuralNetworks.jl Documentation","title":"Models: populations, connections, and stimuli","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"SpikingNeuralNetworks.jl builds on the idea that a neural network is composed of three classes of objects: the network populations, their recurrent connections, and the external stimuli they receive. Thus, a SNN model is simply a NamedTuple with keys: pop, syn, stim. The element associated with the keys must be concrete subtypes of AbstractPopulation, AbstractConnection, or AbstractStimulus. ","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Models can be generated using compose with any population, connection, or stimulus type as keyworded arguments. The user can define the model by associating the correct subtypes to the named tuple, but we advise against it. For example:","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"using SpikingNeuralNetworks\n\nE = SNN.IF(N = 100) # create an Integrate-and-Fire model population with 100 neurons. Use default parameters\n\nEE = SNN.SpikingSynapse(E, E, :ge, w = rand(E.N, E.N)) # connect the populations with recurrent, spiking synapses, targeting the :ge field.\nmy_model = SNN.compose(E=E, EE=EE) # create a model with the E population and the EE connection.\n# my_model = SNN.compose(;E, EE) # equivalent","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"compose assigns the correct types to the pop and syn and carries further integrity checks.  The population and synapse elements will be assigned to my_model.pop.E and my_model.syn.EE, respectively.","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"note: Note\nUser are not expected to use the abstract types, but only their concrete subtypes.\nModels must at least include one population. Connections and Stimuli always target one population.\nBecause in biophysical models connections are typically synapses, the two terms are used interchangeably. ","category":"page"},{"location":"#Pre-existing-models","page":"SpikingNeuralNetworks.jl Documentation","title":"Pre-existing models","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"For each subtype, JuliaSNN offers a library of pre-existing models. In the case above, an integrate-and-fire population (IF<:AbstractPopulation), a spiking synapse (SpikingSynapse<:AbstractSynapse). The collection of available models can be found under Models.","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Models can also be extended by importing the AbstractPopulation, AbstractConnection, or AbstractStimulus types. Guidelines on how to create new models are presented in Models Extensions  (WIP)","category":"page"},{"location":"#Simulation","page":"SpikingNeuralNetworks.jl Documentation","title":"Simulation","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Leveraging Julia's multiple dispatch, the simulation loop calls the methods defined for each type of model and parameter:","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"\nfunction sim!(...)\n    update_time!(T, dt)\n    for s in stimuli\n        s_type = getfield(s, :param)\n        stimulate!(s, s_type, T, dt)\n        record!(s, T)\n    end\n    for p in populations\n        p_type = getfield(t, :param)\n        integrate!(p, p_type, dt)\n        record!(p, T)\n    end\n    for c in connections\n        c_type = getfield(c, :param)\n        forward!(c, c_type)\n        ## if train!(...) \n            plasticity!(c, c.param, dt, T)\n        record!(c, T)\n    end\nend","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"In a loop step, the first to be activated are the stimuli which provide inputs to the populations. Thus, the differential equations associated to the populations are integrated. Finally, the population activity is propagated through the synapses (connections!). ","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"Using Julia's passing-by-sharing, connections and stimuli maintain internal pointers to the populations' fields they are attached to. This allow to seamlessy read and updates the populations variables within the stimulate! and forward! functions.","category":"page"},{"location":"#Installation","page":"SpikingNeuralNetworks.jl Documentation","title":"Installation","text":"","category":"section"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"JuliaSNN/SpikingNeuralNetworks.jl is not yet available on the public Julia repository! For the moment ]add SpikingNeuralNetworks will still direct you to the old version of the package. ","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"You can install the latest version directly from the git repository:","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"]add https://github.com/JuliaSNN/SpikingNeuralNetworks.jl","category":"page"},{"location":"","page":"SpikingNeuralNetworks.jl Documentation","title":"SpikingNeuralNetworks.jl Documentation","text":"To learn how to use the library you can follow the Tutorial.","category":"page"}]
}
