<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Models Extensions · Julia SpikingNeuralNetworks</title><meta name="title" content="Models Extensions · Julia SpikingNeuralNetworks"/><meta property="og:title" content="Models Extensions · Julia SpikingNeuralNetworks"/><meta property="twitter:title" content="Models Extensions · Julia SpikingNeuralNetworks"/><meta name="description" content="Documentation for Julia SpikingNeuralNetworks."/><meta property="og:description" content="Documentation for Julia SpikingNeuralNetworks."/><meta property="twitter:description" content="Documentation for Julia SpikingNeuralNetworks."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Julia SpikingNeuralNetworks logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Julia SpikingNeuralNetworks</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SpikingNeuralNetworks.jl Documentation</a></li><li><a class="tocitem" href="../api_reference/">API References</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../examples/">Tutorial</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../models/">Models</a></li><li class="is-active"><a class="tocitem" href>Models Extensions</a><ul class="internal"><li><a class="tocitem" href="#Adding-a-Population-Model"><span>Adding a Population Model</span></a></li><li><a class="tocitem" href="#Adding-a-Stimulus-Model"><span>Adding a Stimulus Model</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Models Extensions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Models Extensions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSNN/SpikingNeuralNetworks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSNN/SpikingNeuralNetworks.jl/blob/main/docs/src/models_ext.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Models-Extensions"><a class="docs-heading-anchor" href="#Models-Extensions">Models Extensions</a><a id="Models-Extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Models-Extensions" title="Permalink"></a></h1><p>Users can define new concrete types of the three abstract models (<code>AbstractPopulation</code>, <code>AbstractStimulus</code>, and <code>AbstractSynapse</code>) to extend the functionality of the SpikingNeural Networks package.</p><p>New populations, stimuli, or synapses models can be added by users by defining new types.</p><h2 id="Adding-a-Population-Model"><a class="docs-heading-anchor" href="#Adding-a-Population-Model">Adding a Population Model</a><a id="Adding-a-Population-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-Population-Model" title="Permalink"></a></h2><p>To add a new population model, users need to define a new concrete type that inherits from <code>AbstractPopulation</code>. The new population model should include the following:</p><ol><li><strong>Parameters</strong>: Define a new type for the parameters of the population model. This type should inherit from <code>AbstractPopulationParameter</code>.</li><li><strong>State Variables</strong>: Define the state variables of the population model. These variables should be included in the new type that inherits from <code>AbstractPopulation</code>.</li><li><strong>Integration Function</strong>: Define a <code>integrate(population::P, param::T, dt::Float32) where {P&lt;:AbstractPopulation, T&lt;:AbstractPopulationParameter}</code> function to integrate the population model. This function should update the state variables of the population model at each time step.</li></ol><h3 id="Current-based-IF"><a class="docs-heading-anchor" href="#Current-based-IF">Current-based IF</a><a id="Current-based-IF-1"></a><a class="docs-heading-anchor-permalink" href="#Current-based-IF" title="Permalink"></a></h3><pre><code class="language-julia hljs">using SpikingNeuralNetworks
using Distributions
SNN.@load_units

# The macro @eval is used to define the new neuron model within the SNNModels module. It is equivalent to add a new file in the SNNModels.jl/src/populations directory. We strongly suggest this approach to avoid complications with the module system.
@eval SNN.SNNModels begin

    &quot;&quot;&quot;
    Define the neuron model parameters.
    Parameters are used at integration time to compute the equation update.
    All parameters are optional. We strongly advise using SI units and default values.
    &quot;&quot;&quot;
    NeuronParameter
    @snn_kw struct NeuronParameter &lt;: AbstractPopulationParameter
        # adex parameters
        R::Float32 = 1f0GΩ
        Er::Float32 = -70.6f0
        Vt::Float32 = -50.4f0
        up::Float32 = 0.1f0 * ms
        τabs::Float32 = 0.1f0 * ms
        τe::Float32 = 10f0ms
        τi::Float32 = 10f0ms
    end

    &quot;&quot;&quot;
    Define the neuron model.
    The neuron model holds the parameters and state variables of the neuron.
    The state variables are used to compute the equation update at integration time and can be recorded.

    The entries:
     - `param::NeuronParameter`: The parameters of the neuron model.
     - `N::Int64`: The number of neurons in the population.
     - `name::String`: The name of the neuron population.
     - `id::String`: A unique identifier for the neuron population.
     - `records::Dict{Symbol, Any}`: A dictionary to store recorded variables.
    are compulsory
    &quot;&quot;&quot;
    Neuron

    @snn_kw struct Neuron &lt;: AbstractPopulation
        param::NeuronParameter = NeuronParameter()
        N::Int64 = 10
        name::String= &quot;Neuron&quot;
        id::String = randstring(12)
        v::Vector{Float32} = ones(Float32, N)*-70.6f0  # Initial membrane potential
        ge::Vector{Float32} = zeros(Float32, N)
        gi::Vector{Float32} = zeros(Float32, N)
        fire::Vector{Bool} = falses(N)
        I::Vector{Float32} = zeros(Float32, N)
        records::Dict{Symbol, Any} = Dict{Symbol, Any}()
    end

    &quot;&quot;&quot;
    Integrate the neuron model.
    The function integrate!(p::Neuron, param::NeuronParameter, dt::Float32) is mandatory for the a Population model
    and is used to update the state variables of the neuron model at each time step.

    The function must only define the integration step, the recordings are handled by the simulation engine. 
    The following present a good practice to implement the integration step:
    - Use the `@unpack` macro to extract the state variables from the neuron model.
    - Use the `@inbounds` macro to skip bounds checking for performance reasons.
    - Update the state variables in a for loop over the number of neurons `N`.
    - Update the state variables using the timestep `dt` and the parameters from `param`.

    The macro `@inbounds` is used to skip bounds checking for performance reasons. It leads to segment faults if the indices are out of bounds.

    The macro `@fastmath` is used to allow the compiler to use fast math operations, which may lead to slight inaccuracies but improves performance. We consider that in the context of biophysical networks this imprecisions are not critical.
    &quot;&quot;&quot;
    integrate!

    function integrate!(p::Neuron, param::NeuronParameter, dt::Float32)
        @unpack N, v, ge, gi, fire, I = p
        @inbounds @fastmath for i in 1:N
            if fire[i]
                v[i] = param.Er
                fire[i] = false
            else
                v[i] += dt*(param.Er - v[i] +
                        (ge[i] - gi[i]) * param.R +
                        I[i] * param.R )
            end
            ge[i] -= ge[i] / param.τe * dt
            gi[i] -= gi[i] / param.τi * dt
            if v[i] &gt;= param.Vt
                fire[i] = true
                v[i] = 20*mV  # Reset membrane potential after firing
            end
        end
    end
    export Neuron, NeuronParameter, integrate!
end

import SpikingNeuralNetworks: NeuronParameter, Neuron, CurrentNoiseParameter, CurrentStimulus, compose, sim!, monitor!, vecplot
# validate_population_model(SNN.Neuron()) # This is only available in SNNModels v1.5.5

param = NeuronParameter()
neuron = Neuron(param=param, N=1)
# Create a withe noise input current
current_param = CurrentNoiseParameter(neuron.N; I_base = 0pA, I_dist = Normal(-50pA, 100pA))
current_stim = CurrentStimulus(neuron, :I, param = current_param)

monitor!(neuron, [:v, :fire, :ge, :gi, :I], sr = 2kHz)
model = compose(; neuron, current_stim)
sim!(; model, duration = 1000ms, pbar=true)

vecplot(
    neuron,
    :v,
    add_spikes = true,
    ylabel = &quot;Membrane potential (mV)&quot;,
    # ylims = (-80, 10),
    c = :black,
)</code></pre><h2 id="Adding-a-Stimulus-Model"><a class="docs-heading-anchor" href="#Adding-a-Stimulus-Model">Adding a Stimulus Model</a><a id="Adding-a-Stimulus-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-a-Stimulus-Model" title="Permalink"></a></h2><p>Thanks to the multidispatching the simulation loop will call the function that matches the <code>population</code>, <code>stimulus</code>, or <code>connection</code> type and its parameter. Thus we don&#39;t need to always define a new type, defining a new parameter and a function that specializes for it is sufficient to introduce a new behaviour.</p><p>Here we extend the <code>PoissonStimulus&lt;:AbstractStimulus</code> adding a new <code>PoissonRefractoryParameter&lt;:AbstractStimulusParameter</code>. We use the function <code>PoissonLayer</code> to create an input layer that stimulate the postsynaptic population with Poisson distributed spikes with a ΔT absolute refractory period. </p><h3 id="Poisson-Stimulus-with-refractory-time"><a class="docs-heading-anchor" href="#Poisson-Stimulus-with-refractory-time">Poisson Stimulus with refractory time</a><a id="Poisson-Stimulus-with-refractory-time-1"></a><a class="docs-heading-anchor-permalink" href="#Poisson-Stimulus-with-refractory-time" title="Permalink"></a></h3><pre><code class="language-julia hljs">using SpikingNeuralNetworks
using Distributions
SNN.@load_units
using ProtoStructs

# The macro @eval is used to define the new neuron model within the SNNModels module. It is equivalent to add a new file in the SNNModels.jl/src/populations directory. We strongly suggest this approach to avoid complications with the module system.
@eval SNN.SNNModels begin

    &quot;&quot;&quot;
    Define the Poisson refractory stimulus parameters.
    Parameters are used at integration time to compute the equation update.
    All parameters are optional. 
    &quot;&quot;&quot;
    PoissonRefractoryParameter

    @snn_kw struct PoissonRefractoryParameter &lt;: PoissonStimulusParameter #{R} where {R&lt;:Float32}
    # @proto struct PoissonRefractoryParameter{R = Float32} 
        ΔT::Float32 = 2f0ms  # Absolute refractory period
        N::Int = 100  # Number of neurons
        rate::Float32 = 10Hz
        last_spike::Vector{Float32} = zeros(Float32, N)  # Last spike time for each neuron
        rates::Vector{Float32} = fill(rate, N)  # Firing rate for each neuron
        p::Float32 = 0.1f0  # Fraction of neurons receiving the stimulus
        μ::Float32 = 1f0  # Mean of the weight distribution
        σ::Float32 = 0f0  # Standard deviation of the weight distribution
        active::Vector{Bool} = [true]  # Active neurons
    end

    &quot;&quot;&quot;
    Generate a Poisson stimulus with an absolute refractory period for a postsynaptic population.
    &quot;&quot;&quot;
    function stimulate!(
        p::PoissonStimulus,
        param::PoissonRefractoryParameter,
        time::Time,
        dt::Float32,
    )
        @unpack N, randcache, fire, neurons, colptr, W, I, g = p
        @unpack rates, ΔT, last_spike = param
        current_time = get_time(time)
        rand!(randcache)
        @inbounds @simd for j = 1:N
            if (current_time - last_spike[j]) &gt; ΔT &amp;&amp; randcache[j] &lt; rates[j] * dt
                fire[j] = true
                last_spike[j] = current_time
                @fastmath @simd for s ∈ colptr[j]:(colptr[j+1]-1)
                    g[I[s]] += W[s]
                end
            else
                fire[j] = false
            end
        end
    end
    export PoissonRefractoryParameter, stimulate!
end

import SpikingNeuralNetworks: PoissonLayer, PoissonRefractoryParameter, compose, sim!, monitor!, vecplot
# validate_population_model(SNN.Neuron()) # This is only available in SNNModels v1.5.5

neuron_param = SNN.IdentityParam()
neuron = SNN.Identity(; param = neuron_param, N = 1, name = &quot;Identity Neuron&quot;)

# Create a withe noise input current
stim_param = PoissonRefractoryParameter(N=1, ΔT = 20ms, p=1)
stim = PoissonLayer(neuron, :g; param=stim_param)

monitor!(neuron, [:g, :fire], sr = 2kHz)
model = compose(; neuron, stim)
sim!(; model, duration = 100000ms, pbar=true)

vecplot(
    neuron,
    :g,
    neurons=1,
    add_spikes = true,
    ylabel = &quot;Membrane potential (mV)&quot;,
    xlims = (0, 1000ms),
    # ylims = (-80, 10),
    c = :black,
)

st = SNN.spiketimes(neuron)[1]
diff(st) |&gt; x-&gt; SNNPlots.histogram(x, bins=100)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Models</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 19 August 2025 14:07">Tuesday 19 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
