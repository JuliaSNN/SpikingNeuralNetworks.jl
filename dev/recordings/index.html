<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Recordings · Julia SpikingNeuralNetworks</title><meta name="title" content="Recordings · Julia SpikingNeuralNetworks"/><meta property="og:title" content="Recordings · Julia SpikingNeuralNetworks"/><meta property="twitter:title" content="Recordings · Julia SpikingNeuralNetworks"/><meta name="description" content="Documentation for Julia SpikingNeuralNetworks."/><meta property="og:description" content="Documentation for Julia SpikingNeuralNetworks."/><meta property="twitter:description" content="Documentation for Julia SpikingNeuralNetworks."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Julia SpikingNeuralNetworks logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Julia SpikingNeuralNetworks</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">SpikingNeuralNetworks.jl Documentation</a></li><li><a class="tocitem" href="../api_reference/">API References</a></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../examples/">Tutorial</a></li><li><a class="tocitem" href="../models/">Models</a></li><li><a class="tocitem" href="../models_ext/">Models Extensions</a></li><li class="is-active"><a class="tocitem" href>Recordings</a><ul class="internal"><li><a class="tocitem" href="#Population-Variables"><span>Population Variables</span></a></li><li><a class="tocitem" href="#Synaptic-Variables"><span>Synaptic Variables</span></a></li></ul></li><li><a class="tocitem" href="../visualization/">Plots</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Recordings</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Recordings</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaSNN/SpikingNeuralNetworks.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaSNN/SpikingNeuralNetworks.jl/blob/main/docs/src/recordings.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Recordings"><a class="docs-heading-anchor" href="#Recordings">Recordings</a><a id="Recordings-1"></a><a class="docs-heading-anchor-permalink" href="#Recordings" title="Permalink"></a></h1><p>One of the strengths of the <strong>SpikingNeuralNetworks.jl</strong> library is its easy access to all network variables. You can record any dynamic variable used at runtime, and to optimize memory usage, recordings can be subsampled.</p><p>To demonstrate how recordings work, let’s instantiate a network model with excitatory and inhibitory recurrent connections. Excitatory connections follow <strong>short-term plasticity (STP)</strong>, while inhibitory connections use <strong>long-term plasticity (LTP)</strong>. We will show how to record different types of variables simulated in the network.</p><pre><code class="language-julia hljs">using SpikingNeuralNetworks
using Statistics
SNN.@load_units

# AdEx neuron with fixed external current connections with multiple receptors
E = SNN.AdEx(; N = 800, param = SNN.AdExParameter(; El = -50mV))
I = SNN.IF(; N = 200, param = SNN.IFParameter())
EE = SNN.SpikingSynapse(E, E, :he; μ = 2, p = 0.02, STPParam = SNN.MarkramSTPParameter())
EI = SNN.SpikingSynapse(E, I, :ge; μ = 30, p = 0.02)
IE = SNN.SpikingSynapse(I, E, :hi; μ = 50, p = 0.02, LTPParam = SNN.iSTDPRate(r=5Hz))
II = SNN.SpikingSynapse(I, I, :gi; μ = 10, p = 0.02)
model = SNN.compose(; E, I, EE, EI, IE, II)</code></pre><p>To monitor any model variable, use the <a href="../api_reference/#SNNModels.monitor!-Union{Tuple{Item}, Tuple{Item, Vector}} where Item&lt;:Union{SNNModels.AbstractConnection, SNNModels.AbstractPopulation, SNNModels.AbstractStimulus}"><code>monitor!</code></a> function. This function takes the component instance (e.g., <code>E</code>) and the symbol (or list of symbols) you want to record. Optionally, you can specify the sampling rate (<code>sr</code>, default: 1kHz) for the recording.</p><hr/><h2 id="Population-Variables"><a class="docs-heading-anchor" href="#Population-Variables">Population Variables</a><a id="Population-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Population-Variables" title="Permalink"></a></h2><p>First, let’s record variables associated with populations. We will record the excitatory and inhibitory conductances (<code>:ge</code>, <code>:gi</code>), firing rate (<code>:fire</code>), and membrane potential (<code>:v</code>) for all populations in the network model.</p><pre><code class="language-julia hljs">SNN.monitor!(E, [:ge, :gi], sr=200Hz)
SNN.monitor!(model.pop, :v, sr=200Hz)
SNN.monitor!(model.pop, :fire)
SNN.sim!(model = model; duration = 5second)</code></pre><p>To access recorded variables, use the <a href="../api_reference/#SNNModels.record-Tuple{Any, Symbol}"><code>record</code></a> function. This function takes the network component and the variable of interest as arguments. It returns an array (neurons × time), interpolated over the interval defined by <code>:start_time</code> and <code>:end_time</code> (the model’s time when <code>monitor!</code> was called and the last time point of the simulation). The resolution of the recording is determined by the sampling rate. Thanks to interpolation, you can access the variable at any continuous time point.</p><pre><code class="language-julia hljs">v = SNN.record(model.pop.E, :v)
@info &quot;V is: type $(nameof(typeof(v))), size $(size(v))&quot;
v[1, 3.14s]
v[1:10, 2.4s:15ms:3.1s]
v, r = SNN.record(model.pop.E, :v, range=true)
@info &quot;V is: type $(nameof(typeof(v))), size $(size(v)), r size: $(size(r))&quot;
v = SNN.record(model.pop.E, :v, interpolate=false)
@info &quot;V is: type $(nameof(typeof(v))), size $(size(v))&quot;</code></pre><div class="admonition is-info" id="Note-605cb1571b2e8ccb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-605cb1571b2e8ccb" title="Permalink"></a></header><div class="admonition-body"><p>Currently, it is not possible to deactivate recordings while keeping the variable in the monitored pool. This behavior may change in future updates.</p></div></div><hr/><h3 id="Spiketimes-and-Firing-Rates"><a class="docs-heading-anchor" href="#Spiketimes-and-Firing-Rates">Spiketimes and Firing Rates</a><a id="Spiketimes-and-Firing-Rates-1"></a><a class="docs-heading-anchor-permalink" href="#Spiketimes-and-Firing-Rates" title="Permalink"></a></h3><p>Spiketimes are stored as <code>SNN.Spiketimes</code>, a <code>Vector</code> of <code>Vector</code>. The first vector contains the spiketimes of each neuron in milliseconds (neurons × times).</p><pre><code class="language-julia hljs"># Spiketimes
spiketimes = SNN.spiketimes(model.pop.E) # All spiketimes
@info &quot;Spiketimes is: type $(nameof(typeof(spiketimes))), size $(size(spiketimes)), neuron 1 has $(length(spiketimes[1])) spikes&quot;

spiketimes = SNN.spiketimes(model.pop.E; interval=0:1ms:5second) # Spiketimes in the specified interval
@info &quot;Spiketimes is: type $(nameof(typeof(spiketimes))), size $(size(spiketimes)), neuron 1 has $(length(spiketimes[1])) spikes&quot;</code></pre><p>For convenience, you can also access binned spikes using <code>bin_spiketimes(comp&lt;:AbstractPopulation; interval::AbstractRange)</code>. This function returns a tuple: a matrix (neurons × bins) where each entry represents the number of spikes in that bin, and the <code>interval</code> range. The spiketimes are binned within the extremes of <code>interval</code>, with the bin width defined by the <code>interval</code> step.</p><pre><code class="language-julia hljs"># Binned spikes
interval = 0:10ms:5s # 
bins, r = SNN.bin_spiketimes(model.pop.E; interval)
@info &quot;Bins is: type $(nameof(typeof(bins))), size $(size(bins)), r size: $(size(r))&quot;</code></pre><p>To directly access the firing rate, use <code>fr, r = SNN.firing_rate(model.pop.E; interval::AbstractRange)</code>. The firing rate is an interpolated array that samples a continuous firing rate signal at the time points defined by <code>interval</code> (a mandatory keyword argument). The continuous signal is obtained by convolving the binned spike train with an alpha-function kernel (time constant τ, default: 10ms). The firing rate is returned as a matrix (neurons × time points), where each entry represents the firing rate in Hz at that time point.</p><pre><code class="language-julia hljs"># Firing rate
fr, r = SNN.firing_rate(model.pop.E; interval) # Interpolated firing rate
@info &quot;Fr is: type $(nameof(typeof(fr))), size $(size(fr)), r size: $(size(r))&quot;
fr, r = SNN.firing_rate(model.pop.E; interval, interpolate=false) # Non-interpolated firing rate
@info &quot;Fr is: type $(nameof(typeof(fr))), size $(size(fr)), r size: $(size(r))&quot;</code></pre><p>You can also access the firing rate for the entire population:</p><pre><code class="language-julia hljs">fr, r, pop_names = SNN.firing_rate(model.pop; interval)</code></pre><p>For simplicity, you can also access firing rates and spike times via the <code>record</code> function:</p><pre><code class="language-julia hljs">fr = SNN.record(model.pop.E, :fire; interval)
@info &quot;Fr is: type $(nameof(typeof(fr))), size $(size(fr))&quot;
fr, r = SNN.record(model.pop.E, :fire; interval, range=true)
@info &quot;Fr is: type $(nameof(typeof(fr))), size $(size(fr)), r size: $(size(r))&quot;
SNN.record(model.pop.E, :spikes)</code></pre><div class="admonition is-info" id="Note-9843a0581c503175"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-9843a0581c503175" title="Permalink"></a></header><div class="admonition-body"><p>The model instance declared in the <code>Main</code> scope (<code>E</code>) and the instance in the network model (<code>model.pop.E</code>) point to the same object in memory. Operating on either is equivalent.</p></div></div><div class="admonition is-info" id="Note-897e32b1a63ccab7"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-897e32b1a63ccab7" title="Permalink"></a></header><div class="admonition-body"><p>Recorded variables are stored in the component’s <code>records</code> field. The storage method is non-trivial and subject to future changes, so we avoid detailing it here.</p></div></div><hr/><h2 id="Synaptic-Variables"><a class="docs-heading-anchor" href="#Synaptic-Variables">Synaptic Variables</a><a id="Synaptic-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Synaptic-Variables" title="Permalink"></a></h2><p>We now add to the recordings the synaptic strength (<code>:W</code>) and efficacy (<code>:ρ</code>) for the inhibitory and excitatory connections. We also record the variables (<code>:x</code> and <code>:u</code>) for the STP in the excitatory connections and the filtered post-synaptic trace of the inhibitory STDP (<code>:tpost</code>). When recording plasticity variables, you must specify which set of variables you are referring to. This can be done using the keyword argument <code>variables</code> or implicitly by adding a third positional argument to the <code>monitor!</code> function.</p><pre><code class="language-julia hljs">SNN.monitor!(EE, [:ρ], sr=10Hz)
SNN.monitor!(EI, [:W], sr=10Hz)
SNN.monitor!(IE, [:tpost]; sr=10Hz, variables=:LTPVars)
SNN.monitor!(EE, [:x, :u], :STPVars; sr=10Hz)
SNN.train!(model = model; duration = 5second)</code></pre><div class="admonition is-warning" id="Warning-f35932254cc4c16f"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-f35932254cc4c16f" title="Permalink"></a></header><div class="admonition-body"><p>Recording synaptic strength or efficacy can be memory-intensive in large networks. We recommend using a low sampling rate.</p></div></div><div class="admonition is-info" id="Note-d304ec1b9fdee681"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d304ec1b9fdee681" title="Permalink"></a></header><div class="admonition-body"><p><code>STPVars</code> and <code>LTPVars</code> are special keywords representing sets of short-term and long-term plasticity-related variables, respectively.</p></div></div><hr/><h3 id="Synaptic-Connectivity"><a class="docs-heading-anchor" href="#Synaptic-Connectivity">Synaptic Connectivity</a><a id="Synaptic-Connectivity-1"></a><a class="docs-heading-anchor-permalink" href="#Synaptic-Connectivity" title="Permalink"></a></h3><p>Synaptic connectivity is stored in a sparse format as a matrix with dimensions <code>(N_post, N_pre)</code>. You can always access the synaptic weights of the connections directly:</p><pre><code class="language-julia hljs">W = SNN.matrix(EE)  # Default: returns the synaptic strength matrix at the last time point
W = SNN.matrix(EE, :W)
ρ = SNN.record(EE, :ρ)</code></pre><h4 id="Accessing-Pre-and-Post-Synaptic-Neurons"><a class="docs-heading-anchor" href="#Accessing-Pre-and-Post-Synaptic-Neurons">Accessing Pre- and Post-Synaptic Neurons</a><a id="Accessing-Pre-and-Post-Synaptic-Neurons-1"></a><a class="docs-heading-anchor-permalink" href="#Accessing-Pre-and-Post-Synaptic-Neurons" title="Permalink"></a></h4><p>You can access the pre- and post-synaptic neurons for a single neuron or a set of neurons:</p><p><strong>Single Neuron</strong></p><pre><code class="language-julia hljs">neuron = 1
Is = SNN.postsynaptic(EE, neuron)  # Post-synaptic neurons
mean(W[Is, neuron])  # Mean synaptic weight of post-synaptic connections
Js = SNN.presynaptic(EE, neuron)  # Pre-synaptic neurons
mean(W[neuron, Js])  # Mean synaptic weight of pre-synaptic connections</code></pre><p><strong>Multiple Neurons</strong></p><pre><code class="language-julia hljs">neurons = 1:10
W = SNN.matrix(EE)
Is = SNN.presynaptic(EE, neurons)  # Pre-synaptic neurons for multiple neurons
Js = SNN.postsynaptic(EE, neurons)  # Post-synaptic neurons for multiple neurons</code></pre><h4 id="Synaptic-Weight-Matrices"><a class="docs-heading-anchor" href="#Synaptic-Weight-Matrices">Synaptic Weight Matrices</a><a id="Synaptic-Weight-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Synaptic-Weight-Matrices" title="Permalink"></a></h4><p>When recorded, the matrix of synaptic weights or synaptic efficacy can be obtained using the <code>record</code> function. The returned value is a sparse matrix in a vector format, where only the non-zero values are maintained.</p><p><strong>Get the sparse vector <code>ρ</code> at time point <code>t</code>:</strong>    This returns only the non-zero elements of the matrix.</p><pre><code class="language-julia hljs">   ρ, r = SNN.record(EE, :ρ, range=true)
   histogram(ρ[:, 6.5s])
   ```

**Reconstruct the full matrix from the sparse vector `ρ` at time point `t`:**
   This operation reverses the sparse representation and returns the full matrix. You can pass either the vector obtained from `SNN.record` or the synapse object and the symbol of the variable.
   ```julia
   ρ_mat1 = SNN.matrix(EE, ρ, 6.5s)
   ρ_mat2 = SNN.matrix(EE, :ρ, 6.5s)
   all(ρ_mat1 .== ρ_mat2)  # true
   ```

**Get the matrix at multiple time points:**
   This returns a 3D array of size `(N_E, N_E, T)`, where `T` is the number of time points in the specified range.
   ```julia
   ρ_T1 = SNN.matrix(EE, :ρ, 6.5s:10ms:7s)
   ρ_T2 = SNN.matrix(EE, ρ, 6.5s:10ms:7s)
   ```

!!! tip
    For visualization, you can use the functions defined in [Plots](@ref) or use packages like `Plots.jl` to plot recorded variables or  
    ```julia
    using Plots
    plot(r, v[1,:], label=&quot;Membrane potential of neuron 1&quot;)
    ```

---

### Plasticity Variables

Plasticity-related variables, such as STP (`:x`, `:u`) or LTP (`:tpost`), can also be accessed using the `record` function by adding the name of the set of variables of interest (`STPVars` or `LTPVars`) as a prefix. For example, to retrieve the STP variables for the synapse `EE`:
</code></pre><p>julia x = SNN.record(EE, :STPVars<em>x) @info &quot;x is: type nameof(typeof(x)), size size(x)&quot; x[1, 3.14s] x[1:10, 2.4s:15ms:3.1s] x, r = SNN.record(EE, :STPVars</em>x, range=true) @info &quot;x is: type nameof(typeof(x)), size size(x), r size: size(r)&quot; x = SNN.record(EE, :STPVars_x, interpolate=false) @info &quot;x is: type nameof(typeof(x)), size size(x)&quot;</p><pre><code class="nohighlight hljs">
Similarly, for LTP variables in the synapse `IE`:
</code></pre><p>julia tpost = SNN.record(IE, :LTPVars<em>tpost) @info &quot;tpost is: type nameof(typeof(tpost)), size size(tpost)&quot; tpost[1, 3.14s] tpost[1:10, 2.4s:15ms:3.1s] tpost, r = SNN.record(IE, :LTPVars</em>tpost, range=true) @info &quot;tpost is: type nameof(typeof(tpost)), size size(tpost), r size: size(r)&quot; tpost = SNN.record(IE, :LTPVars_tpost, interpolate=false) @info &quot;tpost is: type nameof(typeof(tpost)), size size(tpost)&quot; ```</p><div class="admonition is-info" id="Note-d4eff8577e939a3"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-d4eff8577e939a3" title="Permalink"></a></header><div class="admonition-body"><p>High sampling rates or recording many variables simultaneously can impact performance. Use subsampling (<code>sr</code> keyword) to balance memory usage and resolution.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models_ext/">« Models Extensions</a><a class="docs-footer-nextpage" href="../visualization/">Plots »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 31 August 2025 17:15">Sunday 31 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
